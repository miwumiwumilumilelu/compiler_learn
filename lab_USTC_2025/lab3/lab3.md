# _lab3 后端代码生成

**经过 Lab1 和 Lab2，编译器能够将 Cminusf 源代码翻译成 Light IR**

**本次实验要求将 IR 翻译成龙芯汇编指令**

> .
> ├── ...
> ├── include
> │   ├── ...
> │   └── codegen
> │       ├── ASMInstruction.hpp  # 描述汇编指令
> │       ├── CodeGen.hpp         # 后端框架顶层设计
> │       ├── CodeGenUtil.hpp     # 一些辅助函数及宏的定义
> │       └── Register.hpp        # 描述寄存器
> ├── src
> │   ├── ...
> │   └── codegen
> │       ├── CMakeLists.txt
> │       ├── CodeGen.cpp     <-- lab3 第二阶段需要修改的文件
> │       └── Register.cpp
> └── tests
>     ├── ...
>     └── 3-codegen
>         ├── warmup          <-- lab3 第一阶段（代码撰写）
>         └── autogen         <-- lab3 第二阶段的测试



## 1.阶段1：warmup预热实验

> .
> ├── ...
> ├── include
> │   ├── common
> │   └── codegen/*
> └── tests
>     ├── ...
>     └── 3-codegen
>         └── warmup
>             ├── CMakeLists.txt
>             ├── ll_cases          <- 需要翻译的 ll 代码
>             └── stu_cpp           <- 学生需要编写的汇编代码手动生成器

**实验内容**

实验在 `tests/3-codegen/warmup/ll_cases/` 目录下提供了六个 `.ll` 文件。

需要在 `tests/3-codegen/warmup/stu_cpp/` 目录中，依次完成 `assign_codegen.cpp`、`float_codegen.cpp`、`global_codegen.cpp`、`function_codegen.cpp`、`icmp_codegen.cpp` 和 `fcmp_codegen.cpp` 六个 C++ 程序中的 TODO。

这六个程序运行后应该能够生成 `tests/3-codegen/warmup/ll_cases/` 目录下六个 `.ll` 文件对应的汇编程序。





`ffint.s.w $fd, $fj`

- 行为：选择**浮点寄存器** `$fj` 中的整数型定点数转换为单精度浮点数，得到的单精度浮点数写入到浮点寄存器 `$fd` 中

  

在执行下面的指令前，`$ft0` 寄存器的值为 `0x0000_0000_0000_0008`

`ffint.s.w $ft1, $ft0`

执行后，`$ft1` 寄存器的值为?



根据 **IEEE 754 浮点数标准**，一个 32 位单精度浮点数由三部分组成：

* **符号位**（1 位）：表示正负。

* **指数**（8 位）：表示数字的大小范围。

* **尾数**（23 位）：表示数字的精度。



**步骤：**

**a) 标准化**

首先，我们需要将 `8` 转换为科学记数法形式，但基数是 2： **8=1.0×2^3   即0b1000**

**b) 确定每个部分的值**

- **符号位**：因为 8 是正数，所以符号位是 **`0`**。
- **指数**：科学记数法中的指数是 `3`。在 IEEE 754 标准中，指数需要加上一个固定的偏移量 **127**（这个偏移量是为了让指数既能表示正数也能表示负数）。
  - 指数值 = 3 + 127 = 130
  - 将 130 转换为 8 位二进制：`1000 0010`
- **尾数**：标准化后的数字是 `1.0`。尾数只记录小数点后的部分。
  - `1.0` 的尾数部分是 `0`。
  - 为了凑足 23 位，我们需要在后面补 23 个 `0`：
  - `00000000000000000000000`

**c) 组合结果**

现在，我们将这三部分按顺序拼接起来：

| 符号位 (1 bit) | 指数 (8 bits)  | 尾数 (23 bits)                |
| -------------- | -------------- | ----------------------------- |
| **`0`**        | **`10000010`** | **`00000000000000000000000`** |

**组合在一起得到完整的 32 位二进制数：**`0100 0001 0000 0000 0000 0000 0000 0000`

**d) 四位一组转成0x**

- `0100` -> `4`
- `0001` -> `1`
- `0000` -> `0`
- `0000` -> `0`



执行后，`$ft1` 寄存器的值为 `0x0000_0000_4100_0000`（`8.0` 的 FP32 表示）





## 2.阶段2：编译器后端

一个典型的编译器后端从中间代码获取信息，进行**活跃变量分析、寄存器分配、指令选择、指令优化**等一系列流程，最终生成高质量的后端代码。

本次实验，这些复杂的流程被简化，仅追求实现的完整性，要求采用**栈式分配的策略**，完成后端代码生成。

> .
> ├── include
> │   └── codegen/*                   # 相关头文件
> ├── src
> │   └── codegen
> │       └── CodeGen.cpp         <-- 学生需要补全的文件
> └── tests
>     ├── 3-codegen
>     │   └── autogen
>     │       ├── eval_lab3.sh    <-- 测评脚本
>     │       └── testcases       <-- lab3 第二阶段的测例目录一
>     └── testcases_general       <-- lab3 第二阶段的测例目录二

**实验内容**

补全 `src/codegen/CodeGen.cpp` 中的 TODO，并按需修改 `include/codegen/CodeGen.hpp` 等文件，使编译器能够生成正确的汇编代码。