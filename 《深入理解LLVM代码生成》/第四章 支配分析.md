# 第四章 支配分析

## 4.1 支配与逆支配

4.1.1 

支配的定义	 

Dom(w) 表示所有能支配节点w的节点所组成的集合

完美支配节点：除去本节点后的所有支配本节点的集合



**直接支配节点`IDom`：类似于最接近本节点的但又不是自身的支配节点——>相邻**

**支配树`DT`通过`IDom`给出，其用于各种优化，例如循环优化、重新排序基本块、调度指令、构建控制流等**



SSA构造中：**支配边界`DF`确定φ函数位置**

ADCE中（激进的死循环代码消除）：**逆支配边界确定控制依赖，从而确定活跃变量**



**支配边界：当且仅当x支配y的前驱节点，且x不完美支配y时，y是x的一个支配边界**

（因此如果x中的活跃变量在支配边界y包含的节点中也活跃，那么该活跃变量可能来自其他路径，即y中的这些节点是该活跃变量的汇聚节点。而在SSA构造中，则需要在汇聚节点处插入φ函数）



支配：CFG图从上往下看

逆支配：CFG图从下往上看



4.1.2 支配与逆支配含义解析

控制依赖：如果**基本块A支配基本块B**，那么A执行B一定执行，即所有经过A的路径都经过B，因此**基本块A不控制基本块B**

但是如果基本块A有路径到达出口而不经过基本块B，则说明基本块B控制依赖基本块A，因此基本块A一定存在多个后继节点。**基本块B只是其中一个后继节点**（基本块A相当于一个控制是否执行基本块B的开关），**并且基本块B不能逆支配基本块A**（即从A出发有其他路径到达出口）**同时基本块A还应该是距离基本块B最近的节点**（将那些较远的节点视为控制基本块A的执行，而不应该视为控制基本块B的执行）

综上所述，**逆支配边界信息刚好就是控制依赖信息**





## 4.2 支配树和支配边界的实现

Semi-NCA算法相较于SLT算法优势在：

1.在静态构建DT时：统计意义上，更有性能优势

2.在动态增量构建DT时：可以通过批操作合并多次插入和删除边的操作，时间复杂度低



DT增量构建时，**边插入只会影响父特性的变化，边删除只会影响兄弟特性的变化**

**Semi-NCA天然保存依赖节点的深度，因此可以快速计算得出受影响节点以及更新后的支配关系**

DT增量构建是批处理算法，每一次更新都先更新CFG后更新DT，若不想每次更新CFG，可以将多次DT的更新合并成批量进行（基于最初的CFG）



4.2.1

前向边，后向边，树枝或交叉边

`sdom[U] = V` 	V为U的半支配节点 ：存在节点V能到达节点U且DFS序号小于V->U路径经过的所有节点的那个节点



**半支配节点隐含了sdom(n) = u，表示u位于前向边构成的一条路径中，而n的直接支配节点也一定存在于前向边构成的路径中**。
但是u可能不支配n，所以u是IDom(n)的候选节点，如果u不是IDom(n)，说明在u之上可能还有分叉路径，所以只需要找到分叉点即可（递归过程）



4.2.2

LT和Semi—NCA算法详解：

无论是LT算法还是Semi-NCA算法，它们的核心目标都是相同的：为控制流图（CFG）中的每一个节点，高效地计算出其**支配边界**



* **LT**
  * **预处理与半支配点计算 (Semidominators)**：算法首先对CFG进行一次深度优先遍历（DFS），并为每个节点编号。然后，它通过一个精巧的、逆序的遍历，为每个节点 `W` 计算其**半支配点 `sdom(W)`**。半支配点是一个节点的祖先，它是理解直接支配关系的关键中间步骤。
  * **构建支配树**：利用计算好的半支配点信息，算法通过第二趟遍历，为每个节点找出其**直接支配点 `idom(W)`**。所有节点和它们的直接支配关系就构成了完整的支配树。
  * **计算支配边界**：一旦拥有了完整的支配树，就可以通过一个独立的算法来计算支配边界。其基本逻辑是：对于CFG中的每一条边 `X -> Y`，如果 `X` 的支配点不是 `Y` 的支配点，那么 `Y` 就位于从 `X` 到 `Y` 的直接支配点路径上所有节点的支配边界中。

* **Semi-NCA**

  * 该算法基于一个关键的定理，将一个节点的支配边界 `DF(X)` 分解为两个部分：

    * **`DF_local(X)`**：由节点 `X` **直接产生**的边界。即 `X` 的CFG后继中，那些不被 `X` 支配的节点。
    * **`DF_up(X)`**：从 `X` 在支配树中的**所有孩子 `Z`** 那里**“继承”**上来的边界。一个孩子 `Z` 的边界 `DF(Z)` 中，那些不被 `X` 所支配的成员，也需要被合并到 `DF(X)` 中。

    算法流程如下：

    * **前提**：首先需要有支配树（可以用一个比LT更简单的算法构建）。
    * **遍历**：对支配树进行一次**后序遍历**（从叶子节点到根节点）。
    * **计算**：对于当前遍历到的节点 `X`：
      * 先计算 `DF_local(X)`。
      * 然后，对于`X`的每一个孩子`Z`（此时`DF(Z)`已经被计算出来了），将`DF(Z)`中不被`X`支配的成员合并到`DF(X)`中。



4.2.3 支配边界的实现

独立的算法实现：DJ—Grapch 以DT为基础计算DF

Join边定义：对于一条边 `X -> Y`， `Y` 的直接支配点不是 `X` 



如果一条CFG边 `X -> Y` 同时也是支配树中的一条边（即`X`是`Y`的父节点），那么这是一条“顺流而下”的普通边

**汇合边**则是那些**不属于**支配树骨架的CFG边。它们就像是连接不同树枝的“捷径”或“回路”，代表了程序中控制流发生**合并**或**跳转**的地方。正是这些边，创造了支配边界



该算法的思想完全建立在汇合边的概念之上：

1. 找到CFG中所有的汇合边 `X -> Y`。
2. 对于每一条这样的边，目标节点 `Y` 就成为了某些节点的支配边界集合中的一员。
3. `Y` 应该加入哪些节点的支配边界集合呢？它应该加入从 `X` 开始，沿着支配树**向上回溯**，直到到达 `Y` 的支配点为止，这条路径上所有节点的支配边界集合中。

为什么是这样？ 回顾支配边界的定义：`N` 的支配边界包含 `Y`，意味着 `N` 支配 `Y` 的某个前驱（这里是`X`），但 `N` 并不严格支配 `Y`。

- 当我们从 `X` 沿着支配树向上走到 `runner` 时，`runner` 显然支配 `X`。
- 只要 `runner` 还没有到达 `Y` 的支配区域（即 `runner` 不是 `Y` 的支配点），那么 `runner` 就不支配 `Y`。
- 因此，`runner` 满足了“支配`X`”和“不支配`Y`”两个条件，所以 `Y` 必须被加入到 `DF(runner)` 中。



```c
          左侧: 控制流图 (CFG)                                右侧: 支配树 (DT) 与 汇合边
          Represents actual program flow.                   Represents dominance relationships.

                  +-------+                                          +-------+
                  |   A   |                                          |   A   |
                  +-------+                                          +-------+
                  /       \                                         /       \
                 /         \                                       /         \ (树边)
                v           v                                      v           v
          +-------+     +-------+                              +-------+     +-------+
          |   B   |     |   C   |                              |   B   |     |   C   |
          +-------+     +-------+                              +-------+     +-------+
          |   ^  |        |                                    |    .          |
          |   |  |        v                                    |    .          v
          |   |  |    +-------+                                |    .      +-------+
          v   |  |    |   E   |                                |    .......>|   E   | (汇合边)
      +-------+  |    +-------+                                |            +-------+
      |   D   |  |        |                                    |                .
      +-------+  |        v                                    v                . (汇合边)
          |      |    +-------+                              +-------+            .
          |      |--->|   F   |                              |   F   |<...........
          |           +-------+                              +-------+
          |                                                    ^
          |____________________________________________________| (这是D->B的边)


图例 (Legend):
CFG中的箭头 `-->` `v` `^` 代表实际的控制流。
DT中的实线 `/` `\` `|` 代表支配树的父子关系 ("树边")。
DT中的虚线 `.` `.` `.` 代表CFG中存在但非支配树关系的边 ("汇合边")。


```

**1. 左侧 (CFG)**

这幅图描绘了程序的**实际执行路径**。

- 程序从`A`开始，可以走到`B`或`C`。
- `B`可以走到`D`。
- `D`可以跳回`B`（形成一个循环）。
- `C`可以走到`E`。
- `E`可以走到`F`。
- `B`可以走到`F`。



**2. 右侧 (DT) 与 汇合边**

这幅图的核心是展示支配关系和识别汇合边。

- **树边 (实线 `---`)**: 这些是构成支配树“骨架”的边。例如，`A`是`B`的直接支配点，所以`A --- B`是一条树边。`B`是`D`和`F`的直接支配点，所以`B---D`和`B---F`也是树边。
- **汇合边 (虚线 `...`)**: 这些是算法需要寻找的关键边。它们在CFG中存在，但“打破”了支配树的层级。
  - **`D --> B` (显示为从`D`向`B`回指的虚线)**：这是一条典型的**汇合边**。`B`的直接支配点是`A`，不是`D`。这条边创建了一个循环，是支配边界产生的重要来源。
  - **`C --> E` (显示为`C ...> E`)**: 同样是**汇合边**。`E`的直接支配点是`A`，而不是`C`。
  - **`E --> F` (显示为`E ...> F`)**: 也是**汇合边**。`F`的直接支配点是`B`，而不是`E`。

**算法如何利用这张图？**

支配边界的计算算法会遍历左侧CFG中的每一条边，对照右侧的DT进行判断。一旦发现某条边是虚线（汇合边），比如`E --> F`，它就会开始执行“沿支配树向上回溯”的操作：`runner`从`E`开始，沿着支配树（`E`的父节点是`A`）向上走，直到`runner`到达`F`的直接支配点`B`为止。在这个过程中，`F`会被加入到路径上所有节点（这里是`E`和`A`）的支配边界集合中。



## 4.3 支配树算法及其比较，如何快速判断任意两节点支配关系
