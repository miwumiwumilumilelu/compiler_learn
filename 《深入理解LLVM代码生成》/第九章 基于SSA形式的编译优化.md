# 第九章 基于SSA形式的编译优化

**寄存器分配前的优化主要是基于SSA形式的优化**，寄存器分配后则主要是基于非SSA形式的优化

基于SSA形式的机器指令优化主要包括**尾代码重复、Phi优化、栈着色**等优化

流程如下：

前期尾代码重复——Phi优化——栈着色——栈槽分配——死指令消除——指令并行优化——前期循环不变量外提——公共表达式消除——代码下沉——窥孔优化——死指令消除



* **前期尾代码重复——用于消除指令跳转**，“前期”是指寄存器分配前进行的尾代码重复优化，如果有多个不同的代码路径（例如 `if` 和 `else` 分支），它们最终都汇合到同一块**公共的代码序列（“尾代码”）**，那么我们可以将这段“尾代码”**复制**到每一个分支的末尾，从而**消除**从分支跳转到这个公共代码块的`goto`指令
* **Phi优化——移除两类冗余ø函数**，第一类是死变量插入的ø函数、或者由死变量ø函数构成的循环ø函数，第二类是移除源操作数和目的操作数是同一个寄存器的ø函数（对于部分冗余的情况，则不会进行移除，如`v1 = Φ(v1 from BB1, v2 from BB2)`，其经优化后，在BB1的末尾什么也不做，在BB2的末尾插入 `COPY v1, v2`）
* **栈着色——优化局部变量的布局**，减少栈空间的使用（即让不冲突的局部变量分配同一个栈槽来利用栈空间）
* **栈槽分配——将帧索引和栈槽关联在一起**（等价于为栈变量分配栈空间）
* **死指令消除——**根据基本块中的LiveIn、LiveOut信息，从后向前依次遍历MI指令，将死指令删除
* **IPL（指令并行层次）优化——**依赖后端架构的特性进行并行指令优化
* **前期循环不变量外提——将循环不变量提出循环体**，优化循环执行效率，“前期”是指寄存器分配前进行的循环不变量外提
* **公共表达式消除——消除代码中的公共表达式**，减少不必要计算
* **代码下沉——**将分支节点代码下沉到不同分支，本质是将代码执行向后推迟，**可能会因为下沉到的分支不执行而获得执行利益**
* **窥孔优化——**对相邻指令进行局部优化，由于可能会产生新的死代码，所以会再次执行死指令消除操作



## 9.1 前期尾代码重复

原理、如何判断优化收益、如何执行优化

### 9.1.1 尾代码重复原理

**如果两个基本块之间存在跳转指令，那么将后继基本块里的代码提升到前驱基本块中可以移除跳转指令**

当后继基本块中代码较大时会增加代码量，因此LLVM会提供参数`tail-dup-size`来**控制最大重复的指令数**



在寄存器分配前进行优化需要考虑优化对寄存器分配的影响，直观上看将两个基本块的代码合并到一个基本块可能会**增大变量的活跃区间**，从而导致更多的寄存器冲突。因此尾代码重复优化对重复代码进行更多限制，例如对寄存器影响更大的指令如call、ret的代码片段则不允许重复

尾代码重复会影响控制流，所以在进行尾代码优化时对基本块的布局有一定的要求（基本块之间一定存在跳转指令到达的情况）



典型优化场景有2类：

1. **冗余jmp指令优化**
2. **汇聚基本块优化**



### 9.1.2 尾代码收益判断

是否可以对基本块进行尾代码重复优化，主要从优化收益来看：

1. 在特定基本块结构中才能进行尾代码重复

2. **确定最大重复的指令数**，可以通过参数设置`TailDupSize`（默认值为2）实现；

   当要求代码量最小化时，最大重复指令数为1；

   当基本块最后一条指令为间接跳转指令，则最大允许的重复指令数为`TailDupIndirectBranchSize`（默认值为20）

3. **如果有指令明确不可以重复，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isNotDuplicable = true`，表示指令不可重复（例如BPF后端中ret指令不可重复）

4. **如果指令是聚合指令，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isConvergent = true`，表示指令不可重复（聚合指令和控制流相关，重复代码会导致控制流变化，该属性通常用于GPGPU后端）

5. **如果优化发生在寄存器分配前，且基本块中包含ret、call等指令，则放弃执行尾代码重复优化**。ret指令重复后可能会导致更多的代码“膨胀”（ret重复可能会插入额外的CSR（被调用者保存寄存器）指令；call重复可能会导致更多的寄存器溢出）

6. **如果基本块指令有汇编指令，且包含分支指令，则放弃**。可能会导致逻辑错误

7. 如果基本块中所有指令数超过最大重复指令数，则放弃

8. **如果所有的前驱基本块都包含多个后继基本块，则放弃**。因为重复后，如果前驱基本块走另外路径，则会多执行指令，所以不能重复

9. **如果所有的前驱基本块的最后一条指令不是无条件跳转指令，则放弃**



### 9.1.3 执行尾代码重复优化

尾代码重复优化实现步骤：

1. 对基本块的每一个前驱基本块都尝试进行尾代码合并。当前驱基本块只有一个后继基本块且最后一条指令为无条件跳转指令时开始执行代码重复优化，分为两步：

   1. 删除前驱基本块最后一条无条件跳转指令

   2. 将基本块中的每条指令重复放到前驱基本块中。

      如果是ø函数，指令重复操作本质上是在进行ø函数的析构（在前驱基本块中最后的位置增加COPY指令，并移除ø函数中对应前驱基本块的操作数）；

      示例:

      - 优化前:
        - `P`: ...; `jmp T`
        - `T`: `v3 = Φ(v1 from P, v2 from OtherP)`; ...
      - 优化后 (对 `P` 进行操作):
        - `P`: ...; `COPY v3, v1`; ... (这里是T中其他指令的复制)
        - `T`: `v3 = Φ(v2 from OtherP)`; ... (Φ函数被更新)

      如果是一般指令，则进行代码重复时要保证SSA属性；在SSA形式下，每个虚拟寄存器只能被定义一次

   3. 最后更新CFG图，即移除原来的后继基本块，增加新的后继基本块

2. 如果基本块被重复放到了其全部前驱基本块中，则尝试将基本块也放到其相邻基本块中，之后就可以将基本块移除

   当一个基本块 `T` 的代码，被成功地复制到了它的**所有**前驱基本块中时，一个关键的事情发生了：在控制流图（CFG）中，**不再有任何有效的路径可以跳转到 `T` 的开头**。

   - 所有原来指向 `T` 的跳转，现在都指向了 `T` 原来的后继。
   - `T` 变成了一个不可到达的基本块，即**死代码**

3. 对循环场景需要重构ø函数来做特殊处理。

   ```
   b1
   |
   b2——>exit
   ||
   b3
   ```

   b2 b3 构成一个循环，互为后继基本块。需要在基本块b1 b3 后重复b2 的代码

   b3 中ø函数的源操作数来自b1 和 b3

   ```
   b1
   |
   b2
   |
   b3
   ||
   b2——>exit
   ```

   b3 中ø函数的源操作数来自b2 和 b3，因此还要考虑重构ø函数



## 9.2 Phi 优化

分2种情况：

1. ø函数的多个源都使用的是同一个寄存器（即不需要ø函数）

   1. 形式1:ø函数的源寄存器完全相同
   2. 形式2:ø函数有多个源寄存器，其中一个或者多个源寄存器和目的寄存器相同，且除目的寄存器外，其他的源寄存器都完全相同
   3. 形式3:多个ø函数相互为源，构成循环，并且除了循环的源寄存器外，所有ø函数使用的源寄存器都相同

2. ø函数定义的寄存器只在其他ø函数中使用

   其他ø函数都源寄存器被别的ø函数所定义，这样会形成死代码，形成循环，可以进行ø函数的删除



## 9.3 栈着色

LLVM栈帧布局和GCC栈帧布局以及理想栈帧布局不同

**GCC栈着色是通过冲突图**来判断栈变量是否冲突，不冲突的栈变量可以共享栈槽

**LLVM栈着色是通过变量的作用域**来判断变量是否冲突，若变量最后在某处进行了聚合，则说明作用域即生命周期完全冲突，所以不能进行栈槽分配



**栈着色的前提：**

栈着色功能依赖于**伪指令**，通常在前端处理器**生成LLVM IR时生成**，伪指令如LIFETIME_START、LIFETIME_END会**增加栈变量的生命周期**，标记其作用范围



**栈着色的基本思路如下：**

1. 识别MIR中所有的伪指令LIFETIME_START、LIFETIME_END

   由于栈着色会合并栈变量，因此当伪指令个数较小时如少于2个，则没必要进行栈着色优化

2. 识别活跃变量，计算其活跃区间

3. 根据变量的活跃区间判断是否可以进行合并——活跃区间不冲突可共享一个栈槽，而共享一个栈槽的变量可以合并它们的活跃区间。

   实际上要做到合并最优的变量活跃区间是非常困难的，NP难题，目前采用Greedy算法：合并时先对栈变量活跃区间按照**栈变量的存储空间从大到小**排序，**即优先合并存储空间大的栈变量，并记录合并的栈变量信息**

   根据合并的栈变量信息对MIR进行修改有以下3种情况：

   1. **同时合并Alloca**：栈变量都是根据Alloca指令进行分配的，若要合并栈变量，则也需将多个Alloca指令合并为一个，合并时需要保证新的Alloca指令在所有使用它的指令之前定义（在使用前，多个Alloca指令类型应该一致，不一致则需要cast进行类型转换）
   2. 在所有使用栈变量的Alloca指令合并前，栈槽的指令都要替换为合并后的栈槽
   3. **更新内存指令中别名信息**：如果栈变量合并后仍然可以得到合并后变量的别名信息，则更新合并后栈变量的别名信息；如果无法计算得到别名信息，则将合并后的栈变量的别名信息清空

4. 删除MIR栈所有的伪指令LIFETIME_START、LIFETIME_END



栈着色采用**前向数据流分析**，通过伪指令来准确定义活跃变量和其活跃区间。若基于后向数据流分析可能会导致栈变量在分配空间之前被使用，发生非法内存空间情况



## 9.4 栈槽分配

栈槽分配Pass主要确保指令在栈空间的访问是合法的，如果不合法则调整指令，同时为栈变量分配栈槽

处理逻辑：

首先为指令中的**栈槽分配栈空间**（基于栈槽的访问变为基于栈空间的访问）

然后推断指令访问栈空间是否合法，将不合法的指令访问引入新的虚拟寄存器（**栈槽分配从PEI分离出来，为了解决寄存器分配后一些栈变量访问指令仍然不合法的问题**）（一些指令使用立即数作为偏移值，**其范围有对应的约束**，若超出这个范围，则需要对指令进行如下改写），基于偏移值的访问方式改为基于寄存器的访问方式（只需增加指令，将偏移值赋值给新的寄存器，在寄存器分配阶段统一分配物理寄存器）【**PEI：在寄存器分配之后，如果这一阶段进行栈槽分配会带来较差性能，因为PEI阶段寄存器已经分配完成，所以需要较为复杂的算法才能找到一个合适的物理寄存器完成指令交换，算法复杂度为O(n^2)**】

栈空间访问的合法性取决于具体的后端指令设计

在栈变量分配时，需要考虑栈空间增长的方向、变量对齐等信息，以计算栈变量的位置

**LLVM支持栈保护机制**，栈槽分配优化为栈保护的变量进行重新布局（大对象在前，小对象在后，防止溢出）



栈槽分配Pass和PEI都能确认局部变量的栈位置，但是PEI计算位置会更为准确：因为栈槽分配无法确定CSR具体信息且无法确定寄存器分配过程中溢出寄存器的空间大小，而在PEI阶段所有信息都已经确定

假设“栈槽分配”Pass开始工作。它分析代码后，发现有两个局部变量需要放在栈上：

- `int local_A;` (4字节)
- `long long local_B;` (8字节)

它会做出一个**初步的、临时的**布局规划：

**初步布局 (by 栈槽分配Pass):**

```
      +-------------------+
rbp-->|  Old RBP          |  <-- 栈帧基址
      +-------------------+
-8 -->|  int local_A      |  (假设对齐到8字节)
      +-------------------+
-16 ->|  long long local_B|
      +-------------------+
      ...
```

根据这个**临时蓝图**，`local_A`的地址是`[rbp-8]`，`local_B`的地址是`[rbp-16]`。

**然而**，在后续的编译阶段，特别是**PEI (Prolog/Epilog Insertion) Pass**运行时，它会扫描整个函数的**所有**机器指令，然后发现：“噢，这个函数为了计算，用到了物理寄存器 `rbx` 和 `r12`！”

`rbx`和`r12`在x86-64调用约定中是**CSR**。这意味着函数必须在开头把它们的原始值保存到栈上，在结尾再恢复它们。

现在，PEI Pass拿到了**完整的信息**，它知道栈上需要存放的**所有东西**是：`{local_A, local_B, saved_rbx, saved_r12}`。于是，它会制作出**最终的、正确的**布局：

**最终布局 (by PEI Pass):**

```
      +-------------------+
rbp-->|  Old RBP          |
      +-------------------+
-8 -->|  saved_rbx        |  <-- 新增的CSR保存区
      +-------------------+
-16 ->|  saved_r12        |  <-- 新增的CSR保存区
      +-------------------+
-24 ->|  int local_A      |  <-- local_A 的位置被“挤”下去了！
      +-------------------+
-32 ->|  long long local_B|  <-- local_B 的位置也被“挤”下去了！
      +-------------------+
      ...
```



**所以在分配过程中，如果发现不需要引入新的虚拟寄存器，则会将栈槽分配重新推迟到PEI阶段**



## 9.5 死指令消除

LLVM实现：

* **从后向前处理基本块中指令**，能够更为准确、快速
* 检测指令中使用的变量（指虚拟寄存器），指令中直接使用或者跨基本块的活跃变量（或者一些保留的物理寄存器）都需要识别
* 对于没有被使用的变量，删除其定义指令
* 因为没有处理COPY这样的指令的功能，所以不会进行递归处理