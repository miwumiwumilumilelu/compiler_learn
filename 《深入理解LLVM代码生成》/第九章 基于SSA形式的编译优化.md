# 第九章 基于SSA形式的编译优化

**寄存器分配前的优化主要是基于SSA形式的优化**，寄存器分配后则主要是基于非SSA形式的优化

基于SSA形式的机器指令优化主要包括**尾代码重复、Phi优化、栈着色**等优化

流程如下：

前期尾代码重复——Phi优化——栈着色——栈槽分配——死指令消除——指令并行优化——前期循环不变量外提——公共表达式消除——代码下沉——窥孔优化——死指令消除



* **前期尾代码重复——用于消除指令跳转**，“前期”是指寄存器分配前进行的尾代码重复优化，如果有多个不同的代码路径（例如 `if` 和 `else` 分支），它们最终都汇合到同一块**公共的代码序列（“尾代码”）**，那么我们可以将这段“尾代码”**复制**到每一个分支的末尾，从而**消除**从分支跳转到这个公共代码块的`goto`指令
* **Phi优化——移除两类冗余ø函数**，第一类是死变量插入的ø函数、或者由死变量ø函数构成的循环ø函数，第二类是移除源操作数和目的操作数是同一个寄存器的ø函数（对于部分冗余的情况，则不会进行移除，如`v1 = Φ(v1 from BB1, v2 from BB2)`，其经优化后，在BB1的末尾什么也不做，在BB2的末尾插入 `COPY v1, v2`）
* **栈着色——优化局部变量的布局**，减少栈空间的使用（即让不冲突的局部变量分配同一个栈槽来利用栈空间）
* **栈槽分配——将帧索引和栈槽关联在一起**（等价于为栈变量分配栈空间）
* **死指令消除——**根据基本块中的LiveIn、LiveOut信息，从后向前依次遍历MI指令，将死指令删除
* **IPL（指令并行层次）优化——**依赖后端架构的特性进行并行指令优化
* **前期循环不变量外提——将循环不变量提出循环体**，优化循环执行效率，“前期”是指寄存器分配前进行的循环不变量外提
* **公共表达式消除——消除代码中的公共表达式**，减少不必要计算
* **代码下沉——**将分支节点代码下沉到不同分支，本质是将代码执行向后推迟，**可能会因为下沉到的分支不执行而获得执行利益**
* **窥孔优化——**对相邻指令进行局部优化，由于可能会产生新的死代码，所以会再次执行死指令消除操作



## 9.1 前期尾代码重复

原理、如何判断优化收益、如何执行优化

### 9.1.1 尾代码重复原理

**如果两个基本块之间存在跳转指令，那么将后继基本块里的代码提升到前驱基本块中可以移除跳转指令**

当后继基本块中代码较大时会增加代码量，因此LLVM会提供参数`tail-dup-size`来**控制最大重复的指令数**



在寄存器分配前进行优化需要考虑优化对寄存器分配的影响，直观上看将两个基本块的代码合并到一个基本块可能会**增大变量的活跃区间**，从而导致更多的寄存器冲突。因此尾代码重复优化对重复代码进行更多限制，例如对寄存器影响更大的指令如call、ret的代码片段则不允许重复

尾代码重复会影响控制流，所以在进行尾代码优化时对基本块的布局有一定的要求（基本块之间一定存在跳转指令到达的情况）



典型优化场景有2类：

1. **冗余jmp指令优化**
2. **汇聚基本块优化**



### 9.1.2 尾代码收益判断

是否可以对基本块进行尾代码重复优化，主要从优化收益来看：

1. 在特定基本块结构中才能进行尾代码重复

2. **确定最大重复的指令数**，可以通过参数设置`TailDupSize`（默认值为2）实现；

   当要求代码量最小化时，最大重复指令数为1；

   当基本块最后一条指令为间接跳转指令，则最大允许的重复指令数为`TailDupIndirectBranchSize`（默认值为20）

3. **如果有指令明确不可以重复，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isNotDuplicable = true`，表示指令不可重复（例如BPF后端中ret指令不可重复）

4. **如果指令是聚合指令，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isConvergent = true`，表示指令不可重复（聚合指令和控制流相关，重复代码会导致控制流变化，该属性通常用于GPGPU后端）

5. **如果优化发生在寄存器分配前，且基本块中包含ret、call等指令，则放弃执行尾代码重复优化**。ret指令重复后可能会导致更多的代码“膨胀”（ret重复可能会插入额外的CSR（被调用者保存寄存器）指令；call重复可能会导致更多的寄存器溢出）

6. **如果基本块指令有汇编指令，且包含分支指令，则放弃**。可能会导致逻辑错误

7. 如果基本块中所有指令数超过最大重复指令数，则放弃

8. **如果所有的前驱基本块都包含多个后继基本块，则放弃**。因为重复后，如果前驱基本块走另外路径，则会多执行指令，所以不能重复

9. **如果所有的前驱基本块的最后一条指令不是无条件跳转指令，则放弃**



### 9.1.3 执行尾代码重复优化

尾代码重复优化实现步骤：

1. 对基本块的每一个前驱基本块都尝试进行尾代码合并。当前驱基本块只有一个后继基本块且最后一条指令为无条件跳转指令时开始执行代码重复优化，分为两步：

   1. 删除前驱基本块最后一条无条件跳转指令

   2. 将基本块中的每条指令重复放到前驱基本块中。

      如果是ø函数，指令重复操作本质上是在进行ø函数的析构（在前驱基本块中最后的位置增加COPY指令，并移除ø函数中对应前驱基本块的操作数）；

      示例:

      - 优化前:
        - `P`: ...; `jmp T`
        - `T`: `v3 = Φ(v1 from P, v2 from OtherP)`; ...
      - 优化后 (对 `P` 进行操作):
        - `P`: ...; `COPY v3, v1`; ... (这里是T中其他指令的复制)
        - `T`: `v3 = Φ(v2 from OtherP)`; ... (Φ函数被更新)

      如果是一般指令，则进行代码重复时要保证SSA属性；在SSA形式下，每个虚拟寄存器只能被定义一次

   3. 最后更新CFG图，即移除原来的后继基本块，增加新的后继基本块

2. 如果基本块被重复放到了其全部前驱基本块中，则尝试将基本块也放到其相邻基本块中，之后就可以将基本块移除

   当一个基本块 `T` 的代码，被成功地复制到了它的**所有**前驱基本块中时，一个关键的事情发生了：在控制流图（CFG）中，**不再有任何有效的路径可以跳转到 `T` 的开头**。

   - 所有原来指向 `T` 的跳转，现在都指向了 `T` 原来的后继。
   - `T` 变成了一个不可到达的基本块，即**死代码**

3. 对循环场景需要重构ø函数来做特殊处理。

   ```
   b1
   |
   b2——>exit
   ||
   b3
   ```

   b2 b3 构成一个循环，互为后继基本块。需要在基本块b1 b3 后重复b2 的代码

   b3 中ø函数的源操作数来自b1 和 b3

   ```
   b1
   |
   b2
   |
   b3
   ||
   b2——>exit
   ```

   b3 中ø函数的源操作数来自b2 和 b3，因此还要考虑重构ø函数



## 9.2 Phi 优化

分2种情况：

1. ø函数的多个源都使用的是同一个寄存器（即不需要ø函数）

   1. 形式1:ø函数的源寄存器完全相同
   2. 形式2:ø函数有多个源寄存器，其中一个或者多个源寄存器和目的寄存器相同，且除目的寄存器外，其他的源寄存器都完全相同
   3. 形式3:多个ø函数相互为源，构成循环，并且除了循环的源寄存器外，所有ø函数使用的源寄存器都相同

2. ø函数定义的寄存器只在其他ø函数中使用

   其他ø函数都源寄存器被别的ø函数所定义，这样会形成死代码，形成循环，可以进行ø函数的删除



## 9.3 栈着色

LLVM栈帧布局和GCC栈帧布局以及理想栈帧布局不同

**GCC栈着色是通过冲突图**来判断栈变量是否冲突，不冲突的栈变量可以共享栈槽

**LLVM栈着色是通过变量的作用域**来判断变量是否冲突，若变量最后在某处进行了聚合，则说明作用域即生命周期完全冲突，所以不能进行栈槽分配



**栈着色的前提：**

栈着色功能依赖于**伪指令**，通常在前端处理器**生成LLVM IR时生成**，伪指令如LIFETIME_START、LIFETIME_END会**增加栈变量的生命周期**，标记其作用范围



**栈着色的基本思路如下：**

1. 识别MIR中所有的伪指令LIFETIME_START、LIFETIME_END

   由于栈着色会合并栈变量，因此当伪指令个数较小时如少于2个，则没必要进行栈着色优化

2. 识别活跃变量，计算其活跃区间

3. 根据变量的活跃区间判断是否可以进行合并——活跃区间不冲突可共享一个栈槽，而共享一个栈槽的变量可以合并它们的活跃区间。

   实际上要做到合并最优的变量活跃区间是非常困难的，NP难题，目前采用Greedy算法：合并时先对栈变量活跃区间按照**栈变量的存储空间从大到小**排序，**即优先合并存储空间大的栈变量，并记录合并的栈变量信息**

   根据合并的栈变量信息对MIR进行修改有以下3种情况：

   1. **同时合并Alloca**：栈变量都是根据Alloca指令进行分配的，若要合并栈变量，则也需将多个Alloca指令合并为一个，合并时需要保证新的Alloca指令在所有使用它的指令之前定义（在使用前，多个Alloca指令类型应该一致，不一致则需要cast进行类型转换）
   2. 在所有使用栈变量的Alloca指令合并前，栈槽的指令都要替换为合并后的栈槽
   3. **更新内存指令中别名信息**：如果栈变量合并后仍然可以得到合并后变量的别名信息，则更新合并后栈变量的别名信息；如果无法计算得到别名信息，则将合并后的栈变量的别名信息清空

4. 删除MIR栈所有的伪指令LIFETIME_START、LIFETIME_END



栈着色采用**前向数据流分析**，通过伪指令来准确定义活跃变量和其活跃区间。若基于后向数据流分析可能会导致栈变量在分配空间之前被使用，发生非法内存空间情况



## 9.4 栈槽分配

栈槽分配Pass主要确保指令在栈空间的访问是合法的，如果不合法则调整指令，同时为栈变量分配栈槽

处理逻辑：

首先为指令中的**栈槽分配栈空间**（基于栈槽的访问变为基于栈空间的访问）

然后推断指令访问栈空间是否合法，将不合法的指令访问引入新的虚拟寄存器（**栈槽分配从PEI分离出来，为了解决寄存器分配后一些栈变量访问指令仍然不合法的问题**）（一些指令使用立即数作为偏移值，**其范围有对应的约束**，若超出这个范围，则需要对指令进行如下改写），基于偏移值的访问方式改为基于寄存器的访问方式（只需增加指令，将偏移值赋值给新的寄存器，在寄存器分配阶段统一分配物理寄存器）【**PEI：在寄存器分配之后，如果这一阶段进行栈槽分配会带来较差性能，因为PEI阶段寄存器已经分配完成，所以需要较为复杂的算法才能找到一个合适的物理寄存器完成指令交换，算法复杂度为O(n^2)**】

栈空间访问的合法性取决于具体的后端指令设计

在栈变量分配时，需要考虑栈空间增长的方向、变量对齐等信息，以计算栈变量的位置

**LLVM支持栈保护机制**，栈槽分配优化为栈保护的变量进行重新布局（大对象在前，小对象在后，防止溢出）



栈槽分配Pass和PEI都能确认局部变量的栈位置，但是PEI计算位置会更为准确：因为栈槽分配无法确定CSR具体信息且无法确定寄存器分配过程中溢出寄存器的空间大小，而在PEI阶段所有信息都已经确定

假设“栈槽分配”Pass开始工作。它分析代码后，发现有两个局部变量需要放在栈上：

- `int local_A;` (4字节)
- `long long local_B;` (8字节)

它会做出一个**初步的、临时的**布局规划：

**初步布局 (by 栈槽分配Pass):**

```
      +-------------------+
rbp-->|  Old RBP          |  <-- 栈帧基址
      +-------------------+
-8 -->|  int local_A      |  (假设对齐到8字节)
      +-------------------+
-16 ->|  long long local_B|
      +-------------------+
      ...
```

根据这个**临时蓝图**，`local_A`的地址是`[rbp-8]`，`local_B`的地址是`[rbp-16]`。

**然而**，在后续的编译阶段，特别是**PEI (Prolog/Epilog Insertion) Pass**运行时，它会扫描整个函数的**所有**机器指令，然后发现：“噢，这个函数为了计算，用到了物理寄存器 `rbx` 和 `r12`！”

`rbx`和`r12`在x86-64调用约定中是**CSR**。这意味着函数必须在开头把它们的原始值保存到栈上，在结尾再恢复它们。

现在，PEI Pass拿到了**完整的信息**，它知道栈上需要存放的**所有东西**是：`{local_A, local_B, saved_rbx, saved_r12}`。于是，它会制作出**最终的、正确的**布局：

**最终布局 (by PEI Pass):**

```
      +-------------------+
rbp-->|  Old RBP          |
      +-------------------+
-8 -->|  saved_rbx        |  <-- 新增的CSR保存区
      +-------------------+
-16 ->|  saved_r12        |  <-- 新增的CSR保存区
      +-------------------+
-24 ->|  int local_A      |  <-- local_A 的位置被“挤”下去了！
      +-------------------+
-32 ->|  long long local_B|  <-- local_B 的位置也被“挤”下去了！
      +-------------------+
      ...
```



**所以在分配过程中，如果发现不需要引入新的虚拟寄存器，则会将栈槽分配重新推迟到PEI阶段**



## 9.5 死指令消除

LLVM实现：

* **从后向前处理基本块中指令**，能够更为准确、快速
* 检测指令中使用的变量（指虚拟寄存器），指令中直接使用或者跨基本块的活跃变量（或者一些保留的物理寄存器）都需要识别
* 对于没有被使用的变量，删除其定义指令
* 因为没有处理COPY这样的指令的功能，所以不会进行递归处理

  

## 9.6 IPL优化之If-Conversion

`If-Conversion`算法用于**消除跳转指令，并将控制依赖转换为数据依赖**

以下介绍LLVM后端`基于MIR的EarlyIfConversion`，它在寄存器分配之前执行

执行该优化需要后端支持select指令



**实现思路如下：**

1. 后序遍历当前函数的**支配树**基本块节点

2. 检查当前基本块是否可以进行If-Conversion优化；如果不符合优化**约束条件**，则跳过。

   LLVM检查的约束条件非常严格，其只支持非常特定的场景下的优化

   **列举以下约束条件：**

   1. **控制流形态**：只有满足特定控制流形态的代码才能执行优化，If-Conversion的核心思想是把“根据条件跳转到不同代码块”这个控制依赖，转换成“根据条件选择不同数据值”这个数据依赖`result = condition ? value_from_TBB : value_from_FBB`

      目前只支持以下两种：

      * ```
        			+------+
              | Head |
              +------+
              /      \
             /        \
            v          v
        +-----+      +-----+
        | TBB |      | FBB |
        +-----+      +-----+
            \          /
             \        /
              v      v
              +------+
              | Tail |
              +------+
        ```

      * ```
        			+------+
              | Head |
              +------+
              /      \
             /        \ (直接贯穿)
            v          |
        +-----+        |
        | TBB |        |
        +-----+        |
            \          /
             \        /
              v      v
              +------+
              | Tail |
              +------+
        ```

   2. **Head基本块中的条件跳转语句**：跳转语句中的跳转条件是可明确分析的，**要求相应的目标硬件由明确的状态寄存器来实现指令的跳转**，如x86的EFLAGS寄存器

   3. **硬件支持select指令**：Tail中的ø函数需要被重写为select指令，以便将控制流换成顺序指令

      `select dest, src1, src2, condition`，如果`condition`为真，则`dest = src1`，否则`dest = src2`

      这条指令是用来替换`Tail`块中用于合并不同分支结果的ø函数的

   4. TBB和FBB**不能有活跃入参的物理寄存器**：TBB、FBB和Head基本块间的指令依赖**只能是虚拟寄存器间的数据依赖**

   5. TBB和FBB**不能有访存指令**：TBB和FBB指令会被移入Head基本块中，访存指令的移动可能会影响之后的**访存一致性**

      假设TBB中有一条指令`load rax, [ptr]`，而`ptr`这个指针只在条件为真时才是一个有效地址，在条件为假时它可能是个空指针 (`nullptr`)

      **合并优化后**：即使条件为假，这条`load`指令也**会被执行**，导致程序试图从空指针加载数据，直接引发**程序崩溃**。



**If-Conversion具体执行步骤如下：**

控制流：

```
			 +------------+
       | Head:%bb.0 |
       +------------+
       /            \
      /              \
     v                v
+-----------+      +-----------+
| TBB:%bb.1 |      | FBB:%bb.2 |
+-----------+      +-----------+
     \                /
      \              /
       v            v
       +------------+
       | Tail:%bb.3 |
       +------------+
```

支配树：

```
	  	 +------------+
       | Head:%bb.0 |
       +------------+
       /      |     \
      /       |      \
     /        |       \
    v         v        v
+-----------+ +------------+ +-----------+
| TBB:%bb.1 | | Tail:%bb.3 | | FBB:%bb.2 |
+-----------+ +------------+ +-----------+
```

1. 按照**支配树进行后续遍历**，依次判断出%bb.1 %bb.2 %bb.3都不符合If-Conversion的优化形态

2. 继续遍历，直至Head=%bb.0，TBB=%bb.1，FBB=%bb.2，Tail=%bb.3

3. 从后向前遍历基本块Head中的指令，在Head中找到指令插入位置，以便能将基本块TBB和FBB的指令移到Head中，插入位置为指令`TEST32rr %8:gr32,%8:gr32`，这条指令（或类似的 `CMP` 指令）的作用就是设置条件码（如x86的EFLAGS寄存器），这个条件码就是分支的依据

   `Head` 块的最后一条指令一定是条件跳转指令（如 `JE`, `JNE`）

   从后往前找，跳过最后一条跳转指令，它找到的第一条设置了条件码的指令（此处的`TEST`），就是理想的边界。所有从 `TBB` 和 `FBB` 移过来的指令，都将被插入到这条 `TEST` 指令之后

4. 将TBB和FBB中除Terminate以外的指令移入Head中

   编译器会逐一地将 `TBB` 和 `FBB` 中的所有计算指令（不包括它们末尾的跳转指令，即`Terminate`）复制并插入到 `Head` 块中，就放在上一步找到的那个插入点

5. 将基本块Tail中的ø函数用select指令进行重写替换，将相应的搜索指令插入`TEST32rr %8:gr32,%8:gr32`之后（在Head块里），并删除原先的ø函数

6. 删除TBB、FBB这两个基本块以及基本块Head中的跳转指令，并将Tail和Head合并成一个基本块

7. 最后更新支配树和循环分析结果



可参考论文《On Prediecated Execution》



## 9.7 循环不变量外提（LICM）

该优化通过减少不必要的运算，达到减少执行指令的目的

**步骤如下：**

1. 识别自然循环（第五章）

2. 识别自然循环中的循环不变量

3. 判断循环不变量是否可以外提（若可以外提，则表达式满足以下条件）：

   1. 表达式支配所有循环退出点

   2. 循环中表达式是循环内外的唯一定义点

   3. 定义点支配所有使用点

      即在循环内部，从循环的入口到任何一个**使用**这个不变量结果的地方，都必须先经过这个不变量的**定义点**

4. 将满足条件的循环不变量提到循环外，将可外提的表达式提到一个新的基本块中，并将该块放在循环之前调整相应的跳转逻辑



## 9.8 公共子表达式消除

在编译优化时，**若存在一个表达式E之前被计算过，且从之前的计算点到当前程序的执行点，E用到的所有变量的值都没有发生过变化**，那么E被称为公共子表达式

E的值不需再进行计算，可直接重用，可进行CSE优化（公共子表达式消除）

如果优化范围**仅在基本块内**，则称为**局部公共子表达式消除**

如果优化范围**覆盖多个基本块**，则称为全局公共子表达式消除



公共子表达式消除为编译器提供以下收益：

1. 优化代码大小：**消除冗余的代码序列**，直接减少代码量，因此让编译器**可以更充分地使用指令的并发特性**，以优化CPU资源利用
2. 减少代码执行时间：**减少了重复的运算**，可以让程序的执行效率提升
3. 助力其他优化：消除了无用的表达式，可以**简化数据流、控制流的分析过程**
4. 减少寄存器压力：多余的变量被替代，代码所需寄存器数量减少



**a) 优化前**

```
                +---------+
                | a = 10  |
                +---------+
                /         \
               /           \
              v             v
      +---------------+   +---------------+
      | b = a + 6 * 2 |   | c = a + 6 * 2 |
      +---------------+   +---------------+
              |                   |
              v                   v
      +---------------+   +---------------+
      |    b = 22     |   |    c = 22     |
      +---------------+   +---------------+
              |                   |
              v                   v
      +---------------+   +---------------+
      | d = a + b = 22|   | e = a + c = 22|
      +---------------+   +---------------+
```

**b) 优化后**

```
                +---------+
                | a = 10  |
                +---------+
                /         
               /           
              v             
      +---------------+   +---------------+
      | b = a + 6 * 2 |   | c = a + 6 * 2 | (已消除)
      +---------------+   +---------------+
              |                   .
              v                   .
      +---------------+   +---------------+
      |    b = 22     |   |    c = 22     | (已消除)
      +---------------+   +---------------+
              |                   .
              v                   .
      +---------------+   +---------------+
      | d = a + b = 22|   |   e = a + c   | (已消除)
      +---------------+   +---------------+
              |
              |
              v
+-----------------------------------+
| e = a + c = a + b = d = 22        |
+-----------------------------------+
```

计算b到c的过程，a的值没变——c直接复用b的计算结果即可，消除c的表达式，e=a+c替换为e=a+b

计算d到e到过程，a和b的值没变——e直接复用d的结果，e=d



同理用到IR片段中，使用相关后端框架进行编译优化，也是同样步骤

```c++
int cse_example(int a, int b, int c, int d, bool condition) {
    int result;
    if (condition) {
        result = (a * b) + c;
    } else {
        result = (a * b) + d;
    }
    return result;
}
```

```
define i32 @cse_example(i32 %a, i32 %b, i32 %c, i32 %d, i1 %condition) {
entry:
  br i1 %condition, label %if.then, label %if.else

if.then:                                          ; Basic block for the 'if' branch
  %mul1 = mul nsw i32 %a, %b                      ; <--- 第一个乘法计算
  %add1 = add nsw i32 %mul1, %c
  br label %if.end

if.else:                                          ; Basic block for the 'else' branch
  %mul2 = mul nsw i32 %a, %b                      ; <--- 第二个、冗余的乘法计算
  %add2 = add nsw i32 %mul2, %d
  br label %if.end

if.end:                                           ; Common exit block
  %result = phi i32 [ %add1, %if.then ], [ %add2, %if.else ]
  ret i32 %result
}
```

```
define i32 @cse_example(i32 %a, i32 %b, i32 %c, i32 %d, i1 %condition) {
entry:
  %common_mul = mul nsw i32 %a, %b                ; <--- 公共子表达式被提前计算，仅一次
  br i1 %condition, label %if.then, label %if.else

if.then:                                          ; 'if' branch now reuses the result
  %add1 = add nsw i32 %common_mul, %c             ; <--- 直接重用 %common_mul
  br label %if.end

if.else:                                          ; 'else' branch also reuses the result
  %add2 = add nsw i32 %common_mul, %d             ; <--- 直接重用 %common_mul
  br label %if.end

if.end:
  %result = phi i32 [ %add1, %if.then ], [ %add2, %if.else ]
  ret i32 %result
}
```



## 9.9 代码下沉

减少执行的代码，如定义的变量只在一个分支语句中使用，那么将变量定义下沉到分支中

下沉代码基本块需要有多个后继基本块，否则不需要下沉

**具体实现：**

1. **针对COPY指令**进行优化（即对COPY指令合并）

   对于`dst = COPY src`指令，如果src不是通过COPY指令定义，且src和dst寄存器类型相同，则可以将所有的dst替换为src，来优化COPY指令

2. **对于一般指令：**

   1. 后端允许下沉，如ARM后端对CMP指令有特殊约束，在一些情况下不能下沉

      1. 不能移动的指令，不允许下沉

      2. 聚合指令，不允许下沉

         这通常用于GPU等并行计算后端。当并行的多个线程（一个Warp/Wavefront）遇到分支而走向不同路径（发生分歧）后，聚合指令是一个**硬件级别的同步点**，它强制所有分歧的线程必须在这里“再汇合”，然后才能统一继续执行

         如果下沉了聚合指令，就等于告诉不同的线程组在不同的地方汇合。这将彻底破坏硬件的同步模型，导致程序逻辑混乱或死锁

      3. 用于保证实现NULL Check（判空校验的指令）功能，不允许下沉

         ```
         优化前: load 指令在 if 内部，是安全的。
         +--------------------------------+
         |           BB_A                 |
         |   if (ptr != nullptr) {        |
         |      value = load [ptr]  <-- 判空后才执行
         |   }                            |
         +--------------------------------+
         
         错误下沉: 将 load 指令下沉到 if 之外。
         +--------------------------------+
         |           BB_A'                |
         |   value = load [ptr]     <-- 如果 ptr 是 null，这里会直接崩溃！
         |   if (ptr != nullptr) {        |
         |      ... use value ...         |
         |   }                            |
         +--------------------------------+
         ```

      4. 如果def-use寄存器指令在同一个基本块，不允许下沉

      5. 指令必须下沉到当前基本块的一个后继基本块，并且**下沉指令的目标基本块必须支配所有使用该指令定义的寄存器**，否则程序逻辑会出错误，不能下沉

      6. 只有存在收益的场景才能下沉：

         * 下沉的基本块不能逆支配指令下沉前的基本块，由于不存在逆支配约束（即不止一条路径到达出口），因此下沉后的指令次数少于下沉前指令执行次数，否则需要进一步判断收益

         * 指令下沉前位于内部循环，下沉后位于外部循环。下沉后指令执行次数大幅减少，若不能大幅减少则不能下沉

           ```c++
           // 优化前
           for (int i = 0; i < 10; i++) { // 外部循环
               for (int j = 0; j < 100; j++) { // 内部循环
                   x = i * 5; // <--- 这条指令只依赖于'i'
                   sum += x + j;
               }
           }
           
           // 优化后
           for (int i = 0; i < 10; i++) { // 外部循环
               x = i * 5; // <--- 被下沉到这里
               for (int j = 0; j < 100; j++) { // 内部循环
                   sum += x + j;
               }
           }
           ```

         * 下沉的基本块逆支配指令下沉前的基本块，如果下沉后指令定义的寄存器是**用在ø函数中的**，则可以继续下沉

           虽然指令执行次数不变，但这次下沉可以显著缩短一个寄存器的生命周期（活跃区间），从而降低寄存器压力

           **优化前：`v1` 的生命周期很长**

           ```
                        +-----------------------+
                        |        BB_A           |
                        |   v1 = calculation    | <--- v1 在这里被定义
                        +-----------------------+
                                  |
                                  v
                        +-----------------------+
                        |        BB_B           |
                        | (v1 在此期间必须保持活跃) |
                        +-----------------------+
                                  |
                                  v
                        +-----------------------+
                        |        BB_C           |
                        +-----------------------+
                        /                       \
                       /                         \ (另一条路径)
                      v                           v
           +-----------------------+   +-----------------------+
           |        BB_E           |   |        BB_D           |
           | v3 = PHI(v1 from C,   |   |      v2 = ...         |
           |          v2 from D)   |   +-----------------------+
           +-----------------------+             |
                      .                          v
                      .             +-----------------------+
                      .             |        BB_C           |
                                    +-----------------------+
           ```

           **优化后：`v1` 的生命周期缩短**

           我们将 `v1 = calculation` 从 `BB_A` 下沉到了 `BB_B`。

           ```
                        +-----------------------+
                        |        BB_A           |
                        | (寄存器在此处是自由的)  |
                        +-----------------------+
                                  |
                                  v
                        +-----------------------+
                        |        BB_B           |
                        |   v1 = calculation    | <--- v1 被下沉到这里
                        +-----------------------+
                                  |
                                  v
                        +-----------------------+
                        |        BB_C           |
                        +-----------------------+
                        /                       \
                       ... (与优化前相同) ...
           ```

           `v1` 的活跃区间从 `BB_A -> BB_E` 缩短到了 `BB_B -> BB_E`。在 `BB_A` 和 `BB_B` 之间，原本被 `v1` 占用的寄存器现在可以用于其他计算，这可能会避免一次昂贵的**寄存器溢出**

         * 下沉的基本块逆支配指令下沉前的基本块，同时指令还可以再下沉并且有收益，则继续下沉

           **优化前：指令 `x = ...` 位于所有路径的必经之路上**

           ```
                        +---------------------+
                        |        BB_A         |
                        |   x = y + z         | <--- 指令的初始位置
                        +---------------------+
                                  |
                                  v
                        +---------------------+
                        |        BB_B         |
                        +---------------------+
                                  |
                                  v
                        +---------------------+
                        | BB_C: if (condition)|
                        +---------------------+
                        /                     \
                       /                       \
                      v                         v
           +---------------------+   +---------------------+
           |        BB_D         |   |        BB_E         |
           |   a = x + 1         |   |      b = 100        | <--- 这条路径不需要 x
           +---------------------+   +---------------------+
           ```

           **优化后：指令被下沉到只在需要它的路径上**

           编译器执行了一个两步的下沉：`A -> B` (中性)，然后 `B -> D` (有收益)。

           ```
                        +---------------------+
                        |        BB_A         |
                        | (指令已被移走)        |
                        +---------------------+
                                  |
                                  v
                        +---------------------+
                        |        BB_B         |
                        +---------------------+
                                  |
                                  v
                        +---------------------+
                        | BB_C: if (condition)|
                        +---------------------+
                        /                     \
                       /                       \
                      v                         v
           +---------------------+   +---------------------+
           |        BB_D         |   |        BB_E         |
           |   x = y + z         |   |      b = 100        |
           |   a = x + 1         |   +---------------------+
           +---------------------+
           ```

         * 下沉的基本块逆支配指令下沉前的基本块，并且当前指令属于循环，下沉后指令中的操作数活跃区间变小或者寄存器压力没有增加则可以下沉

           ```c++
           +------------------------------------+
           | Loop Header                        |
           | ...                                |
           +------------------------------------+
               |
               v
           +------------------------------------+ <--- v1 活跃区间开始
           | Loop Body Start (Block A)          |
           |   v1 = a + b                       | <--- v1 在循环顶部被定义
           |   ...                              |
           |   ...                              |
           |   v2 = c * d  // 寄存器压力高的区域   |
           |   v3 = e / f  // v1 在此期间一直占用寄存器 |
           |   ...                              |
           |   ...                              |
           |   result = v1 * 2                  | <--- v1 在循环底部被使用
           +------------------------------------+ <--- v1 活跃区间结束
               |
               v (Loop back or exit)
               
           // 问题: v1 在整个循环体中都占着一个寄存器，即使是在中间那段繁忙的计算区域（v2, v3）也一样。
           // 优化后：通过下沉，v1 的活跃区间显著缩短
           // 编译器判断出，从 Block A 下沉到 Block B（紧邻 v1 使用点之前的块）是安全的（逆支配），并且能缩短活跃区间。
           
           +------------------------------------+
           | Loop Header                        |
           | ...                                |
           +------------------------------------+
               |
               v
           +------------------------------------+
           | Loop Body Start (Block A)          |
           |   // v1的定义已被移走             |
           |   // 此时，原本用于v1的寄存器是自由的!|
           |   ...                              |
           |   v2 = c * d  // 可以使用刚才空闲的寄存器 |
           |   v3 = e / f                       |
           |   ...                              |
           |   ...                              |
           +------------------------------------+ <--- v1 活跃区间开始
           | Block B                            |
           |   v1 = a + b                       | <--- v1 被下沉到这里！
           |   result = v1 * 2                  |
           +------------------------------------+ <--- v1 活跃区间结束
               |
               v (Loop back or exit)
           ```

           

      7. 若下沉后的基本块**存在关键边**，判断是否可以拆分关键边：能拆分则规划如何拆分关键边，不能拆分关键边则不能下沉

         ```
               +------------------+
               |      Source      |
               | (有多个出口)     |
               | if(c1) goto Dest |
               | else goto Other  |
               +------------------+
                     |
                     | <--- 这就是关键边 (Critical Edge)
                     |
                     v
               +------------------+   +------------------+
               |       Dest       |   |   AnotherPred    |
               | (有多个入口)     |   +------------------+
               +------------------+           ^
                     ^                        |
                     |________________________|
         ```

         如果我们想把一条指令下沉到 `Source -> Dest` 这条边上，放到 `Source` 会影响到去 `Other` 的路径；放到 `Dest` 会影响到从 `AnotherPred` 来的路径。

   2. 计算下沉指令的位置（通常是ø函数后的第一条指令），并下沉代码

   3. 拆分关键边，并更新拆分边后的频率 ???

3. 进行循环的特别情况处理，如果参数**`SinkInstsIntoCycle`**为True（默认false），则进行下沉处理

   在循环中，候选的下沉指令必须**同时**满足：

   * 是循环不变量
   * 可以安全移动
   * 不能下沉GOT、常量
   * 不是聚合指令
   * 只有一处定义

   **下沉循环指令需要满足支配属性**，否则逻辑不正确



## 9.10 窥孔优化

随着目标架构的指令特征变化而改变策略和优化模式

做一些**细粒度、琐碎的优化**

针对特定指令场景，所以通用性不高



**基本过程：**

遍历每条待优化指令（**时间复杂度随需要匹配的指令序列的复杂度增加而增加**），判断每一条待优化指令与相关指令组成的指令序列是否存在可以优化的模式

如果是，转换成更高效的新指令序列

如果不是，不做优化



LLVM提供了一个多架构共用的窥孔优化Pass，有如下10个左右的子优化项：

* **操作数可交换指令优化**——为了在寄存器分配之后**消除循环依赖产生的冗余复制指令而做的前置优化**，主要是将循环里的一些满足条件的三元操作数指令的两个源操作数交换位置

  * 以累加器为例：

    在SSA形式下，这会被表示为一个Φ函数和一个三元操作指令（如`ADD`）：

    - `v_sum_phi = PHI(v_sum_initial, v_sum_next)`
    - `v_sum_next = ADD v_sum_phi, v_value`

  为了最高效，寄存器分配器非常希望把`v_sum_phi`和`v_sum_next`分配到**同一个物理寄存器**中（比如`p1`）。这样就不需要在每次循环迭代时进行寄存器拷贝

  但这个愿望和指令的具体形式可能会产生冲突，形成一个“死结”，迫使分配器在循环末尾插入一条`COPY p1, p_temp`这样的指令，极大地拖慢循环速度

  **窥孔优化的目的**：提前预判这个“死结”的可能性，并通过交换操作数来解开这个结

  * 条件1:三元操作数指令和循环头里的ø函数形成了循环数据依赖

    **只有存在这种循环依赖，才有可能出现我们上面所说的寄存器分配“死结”**

  * 条件2:三元操作数的目的操作数和其中一个源操作数共用寄存器（即指令汇编如add r1，r1，r2）

    在MIR层面，寄存器分配器**强烈倾向于**将目的寄存器和**第一个**源操作数分配到同一个物理寄存器上

    正是因为存在这种“合并”的偏好，才使得操作数的**顺序**变得至关重要

  * 条件3:三元操作数指令的两个源操作数是可交换的

    * 可交换: `ADD`, `MUL`, `AND`, `OR`, `XOR`。 `a + b` 等于 `b + a`
    * 不可交换: `SUB`, `DIV`。 `a - b` 不等于 `b - a`	

  * 条件4:在使用三元操作数指令时，ø函数的目的操作数不是条件2共用寄存器的源操作数

    循环依赖的核心变量**没有**出现在分配器偏好的第一个源操作数位置上

* **寄存器合并不友好指令优化**——识别和处理一些伪指令和拆分指令以及Bitcast指令

  因为通过这些指令无法看到寄存器的使用情况，寄存器合并优化不会对它们进行处理，所以称它们为“寄存器合并不友好指令”

  该优化为了满足一定条件下，将以上指令转换为COPY指令，方便后续寄存器的合并优化（主要针对COPY指令）

* **比较指令优化**——如果目标架构减法指令具有**直接设置条件码的特性**，**则可用带条件码的减法指令替代一部分比较指令**

* **选择指令优化**——将选择指令优化成**与或、异或**等逻辑运算指令

* **条件跳转指令优化**——**将条件跳转指令和其他指令进行合并，生成另一种形式的条件跳转指令**，从而删除冗余代码

* **寄存器合并友好指令优化**——将目的操作数和源操作数不同的寄存器类型的**COPY指令**优化成相同的寄存器类型（这里指指令间的相同，而不是单条指令目的操作数和源操作数的寄存器相同）的COPY指令，便于后面进行寄存器合并优化

* **删除冗余复制优化**——对于连续的COPY指令，进行冗余删除，和寄存器替换

* **位扩展指令优化**——当位扩展指令的源操作数寄存器还有其他使用点时，在满足数据流正确的情况下，将其他使用点替换为使用COPY位扩展指令的目的操作数寄存器

  为了降低寄存器压力。通过证明扩展后的大寄存器可以兼容小寄存器的所有用途，我们就可以提前“杀死”那个小寄存器，用位扩展后的大寄存器替代，从而减少在程序某个点上同时活跃的寄存器数量

* **常量折叠优化**——做立即数的常量折叠

* **load指令优化**——指令集中的指令大部分可以直接操作内存，因此在一些场景下可以将load折叠到运算指令里

  优化过程如下：

  * 遍历函数中的每条load指令，并判断load指令是否满足以下条件:
    * load指令具有**可折叠属性（在指令信息中描述）**
    * 有一条指令I使用了load指令加载结果寄存器，并且这条指令I具有等价的可以直接操作内存的指令I'
    * load指令到指令I直接没有其他指令会改变load指令结果寄存器中的值
  * 如果满足以上条件，则将指令I转变成指令I'的形式
  * 如果load指令没有其他使用点，则现在可以直接把它删除



