# 第九章 基于SSA形式的编译优化

**寄存器分配前的优化主要是基于SSA形式的优化**，寄存器分配后则主要是基于非SSA形式的优化

基于SSA形式的机器指令优化主要包括**尾代码重复、Phi优化、栈着色**等优化

流程如下：

前期尾代码重复——Phi优化——栈着色——栈槽分配——死指令消除——指令并行优化——前期循环不变量外提——公共表达式消除——代码下沉——窥孔优化——死指令消除



* **前期尾代码重复——用于消除指令跳转**，“前期”是指寄存器分配前进行的尾代码重复优化，如果有多个不同的代码路径（例如 `if` 和 `else` 分支），它们最终都汇合到同一块**公共的代码序列（“尾代码”）**，那么我们可以将这段“尾代码”**复制**到每一个分支的末尾，从而**消除**从分支跳转到这个公共代码块的`goto`指令
* **Phi优化——移除两类冗余ø函数**，第一类是死变量插入的ø函数、或者由死变量ø函数构成的循环ø函数，第二类是移除源操作数和目的操作数是同一个寄存器的ø函数（对于部分冗余的情况，则不会进行移除，如`v1 = Φ(v1 from BB1, v2 from BB2)`，其经优化后，在BB1的末尾什么也不做，在BB2的末尾插入 `COPY v1, v2`）
* **栈着色——优化局部变量的布局**，减少栈空间的使用（即让不冲突的局部变量分配同一个栈槽来利用栈空间）
* **栈槽分配——将帧索引和栈槽关联在一起**（等价于为栈变量分配栈空间）
* **死指令消除——**根据基本块中的LiveIn、LiveOut信息，从后向前依次遍历MI指令，将死指令删除
* **IPL（指令并行层次）优化——**依赖后端架构的特性进行并行指令优化
* **前期循环不变量外提——将循环不变量提出循环体**，优化循环执行效率，“前期”是指寄存器分配前进行的循环不变量外提
* **公共表达式消除——消除代码中的公共表达式**，减少不必要计算
* **代码下沉——**将分支节点代码下沉到不同分支，本质是将代码执行向后推迟，**可能会因为下沉到的分支不执行而获得执行利益**
* **窥孔优化——**对相邻指令进行局部优化，由于可能会产生新的死代码，所以会再次执行死指令消除操作



## 9.1 前期尾代码重复

原理、如何判断优化收益、如何执行优化

### 9.1.1 尾代码重复原理

**如果两个基本块之间存在跳转指令，那么将后继基本块里的代码提升到前驱基本块中可以移除跳转指令**

当后继基本块中代码较大时会增加代码量，因此LLVM会提供参数`tail-dup-size`来**控制最大重复的指令数**



在寄存器分配前进行优化需要考虑优化对寄存器分配的影响，直观上看将两个基本块的代码合并到一个基本块可能会**增大变量的活跃区间**，从而导致更多的寄存器冲突。因此尾代码重复优化对重复代码进行更多限制，例如对寄存器影响更大的指令如call、ret的代码片段则不允许重复

尾代码重复会影响控制流，所以在进行尾代码优化时对基本块的布局有一定的要求（基本块之间一定存在跳转指令到达的情况）



典型优化场景有2类：

1. **冗余jmp指令优化**
2. **汇聚基本块优化**



### 9.1.2 尾代码收益判断

是否可以对基本块进行尾代码重复优化，主要从优化收益来看：

1. 在特定基本块结构中才能进行尾代码重复

2. **确定最大重复的指令数**，可以通过参数设置`TailDupSize`（默认值为2）实现；

   当要求代码量最小化时，最大重复指令数为1；

   当基本块最后一条指令为间接跳转指令，则最大允许的重复指令数为`TailDupIndirectBranchSize`（默认值为20）

3. **如果有指令明确不可以重复，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isNotDuplicable = true`，表示指令不可重复（例如BPF后端中ret指令不可重复）

4. **如果指令是聚合指令，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isConvergent = true`，表示指令不可重复（聚合指令和控制流相关，重复代码会导致控制流变化，该属性通常用于GPGPU后端）

5. **如果优化发生在寄存器分配前，且基本块中包含ret、call等指令，则放弃执行尾代码重复优化**。ret指令重复后可能会导致更多的代码“膨胀”（ret重复可能会插入额外的CSR（被调用者保存寄存器）指令；call重复可能会导致更多的寄存器溢出）

6. **如果基本块指令有汇编指令，且包含分支指令，则放弃**。可能会导致逻辑错误

7. 如果基本块中所有指令数超过最大重复指令数，则放弃

8. **如果所有的前驱基本块都包含多个后继基本块，则放弃**。因为重复后，如果前驱基本块走另外路径，则会多执行指令，所以不能重复

9. **如果所有的前驱基本块的最后一条指令不是无条件跳转指令，则放弃**



### 9.1.3 执行尾代码重复优化

尾代码重复优化实现步骤：

1. 对基本块的每一个前驱基本块都尝试进行尾代码合并。当前驱基本块只有一个后继基本块且最后一条指令为无条件跳转指令时开始执行代码重复优化，分为两步：

   1. 删除前驱基本块最后一条无条件跳转指令

   2. 将基本块中的每条指令重复放到前驱基本块中。

      如果是ø函数，指令重复操作本质上是在进行ø函数的析构（在前驱基本块中最后的位置增加COPY指令，并移除ø函数中对应前驱基本块的操作数）；

      示例:

      - 优化前:
        - `P`: ...; `jmp T`
        - `T`: `v3 = Φ(v1 from P, v2 from OtherP)`; ...
      - 优化后 (对 `P` 进行操作):
        - `P`: ...; `COPY v3, v1`; ... (这里是T中其他指令的复制)
        - `T`: `v3 = Φ(v2 from OtherP)`; ... (Φ函数被更新)

      如果是一般指令，则进行代码重复时要保证SSA属性；在SSA形式下，每个虚拟寄存器只能被定义一次

   3. 最后更新CFG图，即移除原来的后继基本块，增加新的后继基本块

2. 如果基本块被重复放到了其全部前驱基本块中，则尝试将基本块也放到其相邻基本块中，之后就可以将基本块移除

   当一个基本块 `T` 的代码，被成功地复制到了它的**所有**前驱基本块中时，一个关键的事情发生了：在控制流图（CFG）中，**不再有任何有效的路径可以跳转到 `T` 的开头**。

   - 所有原来指向 `T` 的跳转，现在都指向了 `T` 原来的后继。
   - `T` 变成了一个不可到达的基本块，即**死代码**

3. 对循环场景需要重构ø函数来做特殊处理。

   ```
   b1
   |
   b2——>exit
   ||
   b3
   ```

   b2 b3 构成一个循环，互为后继基本块。需要在基本块b1 b3 后重复b2 的代码

   b3 中ø函数的源操作数来自b1 和 b3

   ```
   b1
   |
   b2
   |
   b3
   ||
   b2——>exit
   ```

   b3 中ø函数的源操作数来自b2 和 b3，因此还要考虑重构ø函数



## 9.2 Phi 优化

分2种情况：

1. ø函数的多个源都使用的是同一个寄存器（即不需要ø函数）

   1. 形式1:ø函数的源寄存器完全相同
   2. 形式2:ø函数有多个源寄存器，其中一个或者多个源寄存器和目的寄存器相同，且除目的寄存器外，其他的源寄存器都完全相同
   3. 形式3:多个ø函数相互为源，构成循环，并且除了循环的源寄存器外，所有ø函数使用的源寄存器都相同

2. ø函数定义的寄存器只在其他ø函数中使用

   其他ø函数都源寄存器被别的ø函数所定义，这样会形成死代码，形成循环，可以进行ø函数的删除



## 9.3 栈着色

LLVM栈帧布局和GCC栈帧布局以及理想栈帧布局不同

**GCC栈着色是通过冲突图**来判断栈变量是否冲突，不冲突的栈变量可以共享栈槽

**LLVM栈着色是通过变量的作用域**来判断变量是否冲突，若变量最后在某处进行了聚合，则说明作用域即生命周期完全冲突，所以不能进行栈槽分配



**栈着色的前提：**

栈着色功能依赖于**伪指令**，通常在前端处理器**生成LLVM IR时生成**，伪指令如LIFETIME_START、LIFETIME_END会**增加栈变量的生命周期**，标记其作用范围



**栈着色的基本思路如下：**

1. 识别MIR中所有的伪指令LIFETIME_START、LIFETIME_END

   由于栈着色会合并栈变量，因此当伪指令个数较小时如少于2个，则没必要进行栈着色优化

2. 识别活跃变量，计算其活跃区间

3. 根据变量的活跃区间判断是否可以进行合并——活跃区间不冲突可共享一个栈槽，而共享一个栈槽的变量可以合并它们的活跃区间。

   实际上要做到合并最优的变量活跃区间是非常困难的，NP难题，目前采用Greedy算法：合并时先对栈变量活跃区间按照**栈变量的存储空间从大到小**排序，**即优先合并存储空间大的栈变量，并记录合并的栈变量信息**

   根据合并的栈变量信息对MIR进行修改有以下3种情况：

   1. **同时合并Alloca**：栈变量都是根据Alloca指令进行分配的，若要合并栈变量，则也需将多个Alloca指令合并为一个，合并时需要保证新的Alloca指令在所有使用它的指令之前定义（在使用前，多个Alloca指令类型应该一致，不一致则需要cast进行类型转换）
   2. 在所有使用栈变量的Alloca指令合并前，栈槽的指令都要替换为合并后的栈槽
   3. **更新内存指令中别名信息**：如果栈变量合并后仍然可以得到合并后变量的别名信息，则更新合并后栈变量的别名信息；如果无法计算得到别名信息，则将合并后的栈变量的别名信息清空

4. 删除MIR栈所有的伪指令LIFETIME_START、LIFETIME_END



栈着色采用**前向数据流分析**，通过伪指令来准确定义活跃变量和其活跃区间。若基于后向数据流分析可能会导致栈变量在分配空间之前被使用，发生非法内存空间情况



## 9.4 栈槽分配

栈槽分配Pass主要确保指令在栈空间的访问是合法的，如果不合法则调整指令，同时为栈变量分配栈槽

处理逻辑：

首先为指令中的**栈槽分配栈空间**（基于栈槽的访问变为基于栈空间的访问）

然后推断指令访问栈空间是否合法，将不合法的指令访问引入新的虚拟寄存器（**栈槽分配从PEI分离出来，为了解决寄存器分配后一些栈变量访问指令仍然不合法的问题**）（一些指令使用立即数作为偏移值，**其范围有对应的约束**，若超出这个范围，则需要对指令进行如下改写），基于偏移值的访问方式改为基于寄存器的访问方式（只需增加指令，将偏移值赋值给新的寄存器，在寄存器分配阶段统一分配物理寄存器）【**PEI：在寄存器分配之后，如果这一阶段进行栈槽分配会带来较差性能，因为PEI阶段寄存器已经分配完成，所以需要较为复杂的算法才能找到一个合适的物理寄存器完成指令交换，算法复杂度为O(n^2)**】

栈空间访问的合法性取决于具体的后端指令设计

在栈变量分配时，需要考虑栈空间增长的方向、变量对齐等信息，以计算栈变量的位置

**LLVM支持栈保护机制**，栈槽分配优化为栈保护的变量进行重新布局（大对象在前，小对象在后，防止溢出）



栈槽分配Pass和PEI都能确认局部变量的栈位置，但是PEI计算位置会更为准确：因为栈槽分配无法确定CSR具体信息且无法确定寄存器分配过程中溢出寄存器的空间大小，而在PEI阶段所有信息都已经确定

假设“栈槽分配”Pass开始工作。它分析代码后，发现有两个局部变量需要放在栈上：

- `int local_A;` (4字节)
- `long long local_B;` (8字节)

它会做出一个**初步的、临时的**布局规划：

**初步布局 (by 栈槽分配Pass):**

```
      +-------------------+
rbp-->|  Old RBP          |  <-- 栈帧基址
      +-------------------+
-8 -->|  int local_A      |  (假设对齐到8字节)
      +-------------------+
-16 ->|  long long local_B|
      +-------------------+
      ...
```

根据这个**临时蓝图**，`local_A`的地址是`[rbp-8]`，`local_B`的地址是`[rbp-16]`。

**然而**，在后续的编译阶段，特别是**PEI (Prolog/Epilog Insertion) Pass**运行时，它会扫描整个函数的**所有**机器指令，然后发现：“噢，这个函数为了计算，用到了物理寄存器 `rbx` 和 `r12`！”

`rbx`和`r12`在x86-64调用约定中是**CSR**。这意味着函数必须在开头把它们的原始值保存到栈上，在结尾再恢复它们。

现在，PEI Pass拿到了**完整的信息**，它知道栈上需要存放的**所有东西**是：`{local_A, local_B, saved_rbx, saved_r12}`。于是，它会制作出**最终的、正确的**布局：

**最终布局 (by PEI Pass):**

```
      +-------------------+
rbp-->|  Old RBP          |
      +-------------------+
-8 -->|  saved_rbx        |  <-- 新增的CSR保存区
      +-------------------+
-16 ->|  saved_r12        |  <-- 新增的CSR保存区
      +-------------------+
-24 ->|  int local_A      |  <-- local_A 的位置被“挤”下去了！
      +-------------------+
-32 ->|  long long local_B|  <-- local_B 的位置也被“挤”下去了！
      +-------------------+
      ...
```



**所以在分配过程中，如果发现不需要引入新的虚拟寄存器，则会将栈槽分配重新推迟到PEI阶段**



## 9.5 死指令消除

LLVM实现：

* **从后向前处理基本块中指令**，能够更为准确、快速
* 检测指令中使用的变量（指虚拟寄存器），指令中直接使用或者跨基本块的活跃变量（或者一些保留的物理寄存器）都需要识别
* 对于没有被使用的变量，删除其定义指令
* 因为没有处理COPY这样的指令的功能，所以不会进行递归处理

  

## 9.6 IPL优化之If-Conversion

`If-Conversion`算法用于**消除跳转指令，并将控制依赖转换为数据依赖**

以下介绍LLVM后端`基于MIR的EarlyIfConversion`，它在寄存器分配之前执行

执行该优化需要后端支持select指令



**实现思路如下：**

1. 后序遍历当前函数的**支配树**基本块节点

2. 检查当前基本块是否可以进行If-Conversion优化；如果不符合优化**约束条件**，则跳过。

   LLVM检查的约束条件非常严格，其只支持非常特定的场景下的优化

   **列举以下约束条件：**

   1. **控制流形态**：只有满足特定控制流形态的代码才能执行优化，If-Conversion的核心思想是把“根据条件跳转到不同代码块”这个控制依赖，转换成“根据条件选择不同数据值”这个数据依赖`result = condition ? value_from_TBB : value_from_FBB`

      目前只支持以下两种：

      * ```
        			+------+
              | Head |
              +------+
              /      \
             /        \
            v          v
        +-----+      +-----+
        | TBB |      | FBB |
        +-----+      +-----+
            \          /
             \        /
              v      v
              +------+
              | Tail |
              +------+
        ```

      * ```
        			+------+
              | Head |
              +------+
              /      \
             /        \ (直接贯穿)
            v          |
        +-----+        |
        | TBB |        |
        +-----+        |
            \          /
             \        /
              v      v
              +------+
              | Tail |
              +------+
        ```

   2. **Head基本块中的条件跳转语句**：跳转语句中的跳转条件是可明确分析的，**要求相应的目标硬件由明确的状态寄存器来实现指令的跳转**，如x86的EFLAGS寄存器

   3. **硬件支持select指令**：Tail中的ø函数需要被重写为select指令，以便将控制流换成顺序指令

      `select dest, src1, src2, condition`，如果`condition`为真，则`dest = src1`，否则`dest = src2`

      这条指令是用来替换`Tail`块中用于合并不同分支结果的ø函数的

   4. TBB和FBB**不能有活跃入参的物理寄存器**：TBB、FBB和Head基本块间的指令依赖**只能是虚拟寄存器间的数据依赖**

   5. TBB和FBB**不能有访存指令**：TBB和FBB指令会被移入Head基本块中，访存指令的移动可能会影响之后的**访存一致性**

      假设TBB中有一条指令`load rax, [ptr]`，而`ptr`这个指针只在条件为真时才是一个有效地址，在条件为假时它可能是个空指针 (`nullptr`)

      **合并优化后**：即使条件为假，这条`load`指令也**会被执行**，导致程序试图从空指针加载数据，直接引发**程序崩溃**。



**If-Conversion具体执行步骤如下：**

控制流：

```
			 +------------+
       | Head:%bb.0 |
       +------------+
       /            \
      /              \
     v                v
+-----------+      +-----------+
| TBB:%bb.1 |      | FBB:%bb.2 |
+-----------+      +-----------+
     \                /
      \              /
       v            v
       +------------+
       | Tail:%bb.3 |
       +------------+
```

支配树：

```
	  	 +------------+
       | Head:%bb.0 |
       +------------+
       /      |     \
      /       |      \
     /        |       \
    v         v        v
+-----------+ +------------+ +-----------+
| TBB:%bb.1 | | Tail:%bb.3 | | FBB:%bb.2 |
+-----------+ +------------+ +-----------+
```

1. 按照**支配树进行后续遍历**，依次判断出%bb.1 %bb.2 %bb.3都不符合If-Conversion的优化形态

2. 继续遍历，直至Head=%bb.0，TBB=%bb.1，FBB=%bb.2，Tail=%bb.3

3. 从后向前遍历基本块Head中的指令，在Head中找到指令插入位置，以便能将基本块TBB和FBB的指令移到Head中，插入位置为指令`TEST32rr %8:gr32,%8:gr32`，这条指令（或类似的 `CMP` 指令）的作用就是设置条件码（如x86的EFLAGS寄存器），这个条件码就是分支的依据

   `Head` 块的最后一条指令一定是条件跳转指令（如 `JE`, `JNE`）

   从后往前找，跳过最后一条跳转指令，它找到的第一条设置了条件码的指令（此处的`TEST`），就是理想的边界。所有从 `TBB` 和 `FBB` 移过来的指令，都将被插入到这条 `TEST` 指令之后

4. 将TBB和FBB中除Terminate以外的指令移入Head中

   编译器会逐一地将 `TBB` 和 `FBB` 中的所有计算指令（不包括它们末尾的跳转指令，即`Terminate`）复制并插入到 `Head` 块中，就放在上一步找到的那个插入点

5. 将基本块Tail中的ø函数用select指令进行重写替换，将相应的搜索指令插入`TEST32rr %8:gr32,%8:gr32`之后（在Head块里），并删除原先的ø函数

6. 删除TBB、FBB这两个基本块以及基本块Head中的跳转指令，并将Tail和Head合并成一个基本块

7. 最后更新支配树和循环分析结果



可参考论文《On Prediecated Execution》



## 9.7 循环不变量外提（LICM）

该优化通过减少不必要的运算，达到减少执行指令的目的

**步骤如下：**

1. 识别自然循环（第五章）

2. 识别自然循环中的循环不变量

3. 判断循环不变量是否可以外提（若可以外提，则表达式满足以下条件）：

   1. 表达式支配所有循环退出点

   2. 循环中表达式是循环内外的唯一定义点

   3. 定义点支配所有使用点

      即在循环内部，从循环的入口到任何一个**使用**这个不变量结果的地方，都必须先经过这个不变量的**定义点**

4. 将满足条件的循环不变量提到循环外，将可外提的表达式提到一个新的基本块中，并将该块放在循环之前调整相应的跳转逻辑



## 9.8 公共子表达式消除

在编译优化时，**若存在一个表达式E之前被计算过，且从之前的计算点到当前程序的执行点，E用到的所有变量的值都没有发生过变化**，那么E被称为公共子表达式

E的值不需再进行计算，可直接重用，可进行CSE优化（公共子表达式消除）

如果优化范围**仅在基本块内**，则称为**局部公共子表达式消除**

如果优化范围**覆盖多个基本块**，则称为全局公共子表达式消除



公共子表达式消除为编译器提供以下收益：

1. 优化代码大小：**消除冗余的代码序列**，直接减少代码量，因此让编译器**可以更充分地使用指令的并发特性**，以优化CPU资源利用
2. 减少代码执行时间：**减少了重复的运算**，可以让程序的执行效率提升
3. 助力其他优化：消除了无用的表达式，可以**简化数据流、控制流的分析过程**
4. 减少寄存器压力：多余的变量被替代，代码所需寄存器数量减少



**a) 优化前**

```
                +---------+
                | a = 10  |
                +---------+
                /         \
               /           \
              v             v
      +---------------+   +---------------+
      | b = a + 6 * 2 |   | c = a + 6 * 2 |
      +---------------+   +---------------+
              |                   |
              v                   v
      +---------------+   +---------------+
      |    b = 22     |   |    c = 22     |
      +---------------+   +---------------+
              |                   |
              v                   v
      +---------------+   +---------------+
      | d = a + b = 22|   | e = a + c = 22|
      +---------------+   +---------------+
```

**b) 优化后**

```
                +---------+
                | a = 10  |
                +---------+
                /         
               /           
              v             
      +---------------+   +---------------+
      | b = a + 6 * 2 |   | c = a + 6 * 2 | (已消除)
      +---------------+   +---------------+
              |                   .
              v                   .
      +---------------+   +---------------+
      |    b = 22     |   |    c = 22     | (已消除)
      +---------------+   +---------------+
              |                   .
              v                   .
      +---------------+   +---------------+
      | d = a + b = 22|   |   e = a + c   | (已消除)
      +---------------+   +---------------+
              |
              |
              v
+-----------------------------------+
| e = a + c = a + b = d = 22        |
+-----------------------------------+
```

计算b到c的过程，a的值没变——c直接复用b的计算结果即可，消除c的表达式，e=a+c替换为e=a+b

计算d到e到过程，a和b的值没变——e直接复用d的结果，e=d



同理用到IR片段中，使用相关后端框架进行编译优化，也是同样步骤

```c++
int cse_example(int a, int b, int c, int d, bool condition) {
    int result;
    if (condition) {
        result = (a * b) + c;
    } else {
        result = (a * b) + d;
    }
    return result;
}
```

```
define i32 @cse_example(i32 %a, i32 %b, i32 %c, i32 %d, i1 %condition) {
entry:
  br i1 %condition, label %if.then, label %if.else

if.then:                                          ; Basic block for the 'if' branch
  %mul1 = mul nsw i32 %a, %b                      ; <--- 第一个乘法计算
  %add1 = add nsw i32 %mul1, %c
  br label %if.end

if.else:                                          ; Basic block for the 'else' branch
  %mul2 = mul nsw i32 %a, %b                      ; <--- 第二个、冗余的乘法计算
  %add2 = add nsw i32 %mul2, %d
  br label %if.end

if.end:                                           ; Common exit block
  %result = phi i32 [ %add1, %if.then ], [ %add2, %if.else ]
  ret i32 %result
}
```

```
define i32 @cse_example(i32 %a, i32 %b, i32 %c, i32 %d, i1 %condition) {
entry:
  %common_mul = mul nsw i32 %a, %b                ; <--- 公共子表达式被提前计算，仅一次
  br i1 %condition, label %if.then, label %if.else

if.then:                                          ; 'if' branch now reuses the result
  %add1 = add nsw i32 %common_mul, %c             ; <--- 直接重用 %common_mul
  br label %if.end

if.else:                                          ; 'else' branch also reuses the result
  %add2 = add nsw i32 %common_mul, %d             ; <--- 直接重用 %common_mul
  br label %if.end

if.end:
  %result = phi i32 [ %add1, %if.then ], [ %add2, %if.else ]
  ret i32 %result
}
```



## 9.9 代码下沉