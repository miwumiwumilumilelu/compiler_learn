### 第一部分：面试模拟题库

#### 🟢 基础题 (概念与架构)

1. **请解释LLVM的“三段式”架构及其优势。**
   - **考察点：** 模块化设计、前端/优化器/后端的解耦。
   - **参考答案：** 核心是前端、优化器、后端分离。前端将源码转为IR，优化器优化IR，后端将IR转为机器码。优势在于将 M×N 的编译器开发复杂度降低为 M+N，IR作为通用的“窄腰”连接了多语言和多硬件。
2. **LLVM IR 属于哪种类型的IR？它有什么特点？**
   - **考察点：** 图状IR、CFG、基本块。
   - **参考答案：** LLVM IR属于图状IR (Graph IR)。它将程序表示为控制流图（CFG），节点是基本块，块内是线性指令。这种形式既保留了控制流信息，又便于指令级分析。
3. **什么是基本块 (Basic Block)？**
   - **考察点：** 编译原理基础。
   - **参考答案：** 基本块是CFG的原子单位，是一段只有一个入口和一个出口的连续指令序列。
4. **简述SSA（静态单赋值）及其核心优势。**
   - **考察点：** SSA定义、Def-Use Chain。
   - **参考答案：** SSA要求每个变量只被赋值一次，多次赋值通过重命名（版本化）处理。核心优势是极大地简化了“定义-使用关系”（Def-Use Chain），让数据流分析变得清晰直接。

#### 🟡 进阶题 (SSA构建与性质)

1. **什么是Φ节点 (Phi Node)？它通常出现在哪里？**
   - **考察点：** SSA的实现机制。
   - **参考答案：** Φ节点是SSA中的伪指令，用于根据控制流的来源路径选择变量的版本。它必须放在基本块的起始位置。
2. **Minimal SSA 和 Pruned SSA 有什么区别？**
   - **考察点：** SSA的优化形式。
   - **参考答案：** Minimal SSA 在所有统治边界插入Φ函数；而 Pruned SSA 会结合活性分析，剔除那些定义后从未被使用的“死”变量的Φ函数，生成的IR更简洁。
3. **请解释 Briggs-Cooper 算法的核心思想。**
   - **考察点：** SSA构建优化、活性分析。
   - **参考答案：** 该算法用于构建 Pruned SSA。其核心是在插入Φ函数前增加一步“活性分析”：只有当变量在统治边界节点的入口处是“活跃”的（即后续会被使用），才插入Φ函数，否则进行剪枝。

#### 🔴 专家题 (SSA析构与代码生成)

1. **在将SSA转换回机器码时（SSA析构），为什么不能简单地直接丢弃Φ函数？**
   - **考察点：** 语义等价性。
   - **参考答案：** 物理机器没有Φ指令。必须在Φ函数的前驱块末尾插入等价的 `move` (拷贝) 指令来模拟Φ函数的行为。
2. **什么是“关键边” (Critical Edge)？为什么在SSA析构时需要拆分它？**
   - **考察点：** CFG变换、Sreedhar算法背景。
   - **参考答案：** 关键边是指一个前驱块有多个后继，且后继块有多个前驱的边。如果不拆分关键边，插入的拷贝指令会影响前驱块跳转到其他后继块的正确性（即污染了其他路径）。拆分后，拷贝指令可以安全地放在新插入的空基本块中。
3. **请解释“丢失拷贝问题” (Lost-Copy Problem) 以及 Sreedhar 算法如何解决其中的循环依赖？**
   - **考察点：** 并行拷贝、Swap问题。
   - **参考答案：** 当一个基本块有多个Φ函数且存在依赖（如 `x=y`, `y=x`）时，简单的顺序插入拷贝会导致值被覆盖。Sreedhar算法通过构建依赖图检测环，并引入临时变量（`tmp`）来打破依赖环，从而正确实现并行拷贝。

------

### 第二部分：算法在 LLVM 源码中的位置

LLVM的代码库非常庞大，但核心算法的实现位置相对固定。以下路径基于 `llvm-project` (GitHub) 的结构：

#### 1. SSA 构建 (对应 Briggs-Cooper 思想)

LLVM 不会直接对整个程序“构建SSA”，因为前端生成的IR通常已经是部分SSA形式（除了栈变量）。LLVM使用 `mem2reg` Pass 将栈上分配的变量 (`alloca`) 提升为 SSA 寄存器。这个过程包含了 Φ 函数的插入和剪枝。

- **核心文件：** `llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp`
- **关键类/函数：**
  - `PromoteMemToReg`: 主入口。
  - 该文件实现使用了 **Iterated Dominance Frontiers (IDF)** 算法来放置 Φ 节点。
  - 它在放置时会进行 **Liveness Analysis** (活性分析) 来避免插入死 Φ 节点，这正是 **Briggs-Cooper 算法** 的工程实现。

#### 2. 统治性分析 (Dominance)

SSA 构建的基础是计算统治树和统治边界。

- **核心文件：** `llvm/lib/Analysis/DominanceFrontier.cpp` 和 `llvm/lib/Analysis/Dominators.cpp`
- **功能：** 计算 BasicBlock 的 Dominator Tree 和 Dominance Frontier。

#### 3. SSA 析构 / Φ 消除 (对应 Sreedhar 算法)

这通常发生在代码生成的后端阶段（Backend），将 LLVM IR (SSA) 转换为 机器 IR (非SSA, 或限制性SSA)。

- **核心文件：** `llvm/lib/CodeGen/PHIElimination.cpp`
- **功能：** 这个 Pass 负责消除机器码中的 Φ 节点。
  - **拆分关键边：** 代码中会调用 `SplitCriticalEdge` (位于 `llvm/lib/CodeGen/MachineBasicBlock.cpp` 或 `llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp`)。
  - **解决拷贝依赖：** `PHIElimination` 类中包含了分析 Φ 节点依赖并插入 `COPY` 指令的逻辑。如果发现循环依赖（Swaps），它会使用临时寄存器来解决，这对应了 **Sreedhar 算法** 或其变种处理“丢失拷贝”和“并行拷贝”的逻辑。

#### 4. 链接器与调试器

- **lld (链接器):** `lld/` 目录。
- **lldb (调试器):** `lldb/` 目录。
- **Clang (前端):** `clang/` 目录。

### 复习建议

如果你想深入看源码，建议从 `PromoteMemoryToRegister.cpp` 看起，因为这是将 C/C++ 这种命令式语言的变量转换为 LLVM SSA 形式最关键的步骤。重点关注它是如何使用 `DominanceFrontier` 来决定在哪里放 Φ 的。