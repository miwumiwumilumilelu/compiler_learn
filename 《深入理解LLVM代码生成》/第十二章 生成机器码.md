# 第十二章 生成机器码

编译器执行完指令选择、调度、寄存器分配、编译优化等工作后，最后还需要将编译结果生成用于程序执行的机器码，并将其保存在文件中（这个文件通常称为**可执行文件**），这一过程称为机器码生成

编译器需要按照不同平台生成对应的可执行文件（如Linux对应ELF，Windows对应PE）

因为机器码由0、1构成，没有可读性，在验证、分析编译结果时不方便，所以编译器也提供了将编译结果生成汇编代码的功能，再由汇编器将汇编代码转换为机器码（不同的输出格式对应不同的编译选项来进行控制）

机器码生成的输入为MIR，输出为机器码或者汇编代码，在代码生成过程中还引入了新的中间表示MC（机器代码）

二进制文件——反汇编器——>汇编文件

汇编文件——汇编器——>二进制文件



## 12.1 MC

代码生成和后端强关联，MIR转为MC（MachineInstr转为MCInst）由具体后端完成（如BPF后端生成MC是由BPFMCInstLower实现）

MCInst在设计时进行了抽象，可以描述所有的信息（指令编码信息——操作码和所有的操作数）

MIR使用MachineInstr描述，MC使用MCInst描述

机器码生成的输入是MC而不是MIR的原因如下：

1. 相比MachineInstr，MCInstr的结构更加简单，**更关注代码生成的相关信息**

2. 在实现一个具体后端时，还需要实现相应的汇编器和反汇编工具。**在汇编文件和二进制文件层面，指令信息非常有限**，MCInst作为汇编和反汇编桥梁更好

3. 二进制文件out.o反汇编生成out.s，需要经过指令解码，生成MCInst，输出到汇编文件

   而将文本文件out.s汇编成二进制文件out.o，需要经过文本解析，以生成MCInst、指令编码，并最终输出到二进制文件

   同时这对LLVM中的JIT过程也非常有用

   这样，可以将汇编、反汇编、JIT统一进行

   参考p375 图12-3

4. 在代码生成中涉及可执行文件格式的相关信息，这些信息在MC中通过单独的结构（如MCSection、MCSymbol等）进行管理，使得代码更为清晰



`$r0 = new ADD_ri killed $r0(tied-def 0),1`

MIR——>MC

```
r0 += 1				# <MCInst #259 ADD_ri
							# <MCOperand Reg:1>
							# <MCOperand Reg:1>
							# <MCOperand Imm:1>>
```

三个操作数对应$r0、$r0、1



## 12.2 机器码生成过程

