# 第十二章 生成机器码

编译器执行完指令选择、调度、寄存器分配、编译优化等工作后，最后还需要将编译结果生成用于程序执行的机器码，并将其保存在文件中（这个文件通常称为**可执行文件**），这一过程称为机器码生成

编译器需要按照不同平台生成对应的可执行文件（如Linux对应ELF，Windows对应PE）

因为机器码由0、1构成，没有可读性，在验证、分析编译结果时不方便，所以编译器也提供了将编译结果生成汇编代码的功能，再由汇编器将汇编代码转换为机器码（不同的输出格式对应不同的编译选项来进行控制）

机器码生成的输入为MIR，输出为机器码或者汇编代码，在代码生成过程中还引入了新的中间表示MC（机器代码）

二进制文件——反汇编器——>汇编文件

汇编文件——汇编器——>二进制文件



## 12.1 MC

代码生成和后端强关联，MIR转为MC（MachineInstr转为MCInst）由具体后端完成（如BPF后端生成MC是由BPFMCInstLower实现）

MCInst在设计时进行了抽象，可以描述所有的信息（指令编码信息——操作码和所有的操作数）

MIR使用MachineInstr描述，MC使用MCInst描述

机器码生成的输入是MC而不是MIR的原因如下：

1. 相比MachineInstr，MCInstr的结构更加简单，**更关注代码生成的相关信息**

2. 在实现一个具体后端时，还需要实现相应的汇编器和反汇编工具。**在汇编文件和二进制文件层面，指令信息非常有限**，MCInst作为汇编和反汇编桥梁更好

3. 二进制文件out.o反汇编生成out.s，需要经过指令解码，生成MCInst，输出到汇编文件

   而将文本文件out.s汇编成二进制文件out.o，需要经过文本解析，以生成MCInst、指令编码，并最终输出到二进制文件

   同时这对LLVM中的JIT过程也非常有用

   这样，可以将汇编、反汇编、JIT统一进行

   参考p375 图12-3

4. 在代码生成中涉及可执行文件格式的相关信息，这些信息在MC中通过单独的结构（如MCSection、MCSymbol等）进行管理，使得代码更为清晰



`$r0 = new ADD_ri killed $r0(tied-def 0),1`

MIR——>MC

```
r0 += 1				# <MCInst #259 ADD_ri
							# <MCOperand Reg:1>
							# <MCOperand Reg:1>
							# <MCOperand Imm:1>>
```

三个操作数对应$r0、$r0、1



## 12.2 机器码生成过程

编译器生成MC后就会真正进入代码生成阶段。针对不同平台支持的不同的可执行文件格式，都要有对应的机器码生成。

LLVM同时支持输出到汇编文件和二进制文件，之后分别由不同的类实现对MCStreamer的继承。MCStreamer定义了公共接口，而每一种指示符分别有一个函数与每一种指示符对应，如emitInstruction、emitLabel、emitIntValue等；不同文件格式通过定义类来实现个性化

虽然文件格式不相同，但是它们还是有一些相似部分，**例如不同文件格式可能都会包含全局变量信息、函数的链接信息等**，因此代码生成过程可以总结如下：

1. **生成模块全局信息**： 模块全局信息包括全局变量和常量池等

2. **生成函数体**：函数属性信息和指令信息。

   其中，函数属性包括函数的可见性（即对链接器可见的特性，控制该函数是否可供其他模块链接）、链接特性（链接时是否可以在多文件间共享）、对齐（首地址应该以一定字节数对齐）等

   指令信息是指每一条指令生成的机器码



### 12.2.1 汇编代码生成

C源码转汇编文件

输出前最后一个阶段的MIR，通过`llvm-mc --arch=bpf --show-inst 12-2.s`编译命令，经BPFInstLower处理，将MachineInstr降级为MCInst IR，可进行查看

输出到汇编文件，在汇编文件中，主要包含指令和指示符

1. 指令信息

   指令输出由MCInstPrinter定义接口，具体后端需继承MCInstPrinter类，并实现指令输出的接口

   指令输出的具体实现由`llvm-tblgen`自动生成的

2. 指示符信息

   文件信息和函数头：

   .text指示符是指接下来的信息存储在.text section中

   .p2align 3 用于描述对齐信息，对齐方式为2^3，即按8字节对齐，**函数的对齐方式可按需指定**，通常是在初始化过程中由继承自TargetLowering类的目标后端子类进行设置的

   指示符信息作为指导汇编过程的信息，**通常不占用二进制存储空间**。由于指示符的分类比较多，这里不再展开介绍



### 12.2.2 二进制代码生成

二进制代码生成和汇编代码生成过程基本相似，不同的是**二进制代码生成时需要根据文件进行布局，同时将所有信息（指令和指示符）**

**都变成二进制**

1. 指令信息

   **每条指令都有其对应的编码方式，编码信息保存在xxxInstrInfo.td文件中**，最终由`llvm-tblgen`自动生成编码函数

   一般的指令在编码阶段已经获取了编码的所有信息，包括操作码、寄存器或立即数等，可以直接完成指令编码过程

   而如jmp、call指令等都需要一个目的地，当为这些指令编码时还不能获取全部信息（尚不知道目的地址信息），这就**需要暂时将符号引用的信息保存下来**，在后续获取符号信息之后再对该指令进行修正。其中符号引用类型和处理如下：

   1. **函数内符号引用**即引用的符号属于该函数内部，但是在对当前指令编码时，被引用的符号还未被处理，导致当前指令不能完成编码。例如函数内部的前向跳转指令，由于目标位置处于当前编码指令之后，只有处理到跳转目标指令处，才能计算出两条指令的相对偏移，进而实现对跳转指令的修正
   2. **函数间符号引用**即引用的符号不属于当前函数，但存在于当前编译的模块中。例如函数调用指令，在对当前函数进行汇编的过程中，目标函数可能存在未处理的情况，因而目标函数地址尚不能确定
   3. **模块内的数据引用**，类似于2，不同的是**数据的访问是跨区域（section）的访问**。对2而言，只需要处理.text section以后，对应的函数间符号引用的指令就可以进行修正了，然而存放数据的区域和存放代码的区域位于不同的区域中，因此只有在模型各个区域布局之后，才能对这些数据引用指令进行修正，例如静态数据或常量数据的引用
   4. **跨模块符号引用**，即引用外部符号。这里包括外部数据符号访问和外部函数符号访问。由于**外部符号的具体实现在编译阶段无法获得，转而交由链接器实现符号的查找与链接**。这里就涉及常说的**重定位信息**。即在编译阶段记录一些信息并传给链接器，以指导链接器进行指令修正

   上面是按照被引用符号的范围进行了分类，并简单解释了在什么时间可以获得被引用符号的信息

   至于真正进行指令修正的时机则与具体的编译器实现有关

   * 记录符号引用信息需要明确如下几个问题：

     * **需要修复的指令位置**：描述需要修正的指令在二进制中的偏移

     * **符号引用的信息**：描述指令引用了什么符号

     * **指令修正方式**：描述在获取了被引用符号的地址后，如何修正指令



2. 指示符信息

   指示符处理在生成二进制文件过程中，同12.2.1节介绍略有不同

   例如在前面提到的汇编文件中，不同的区域可穿插布局。比如在汇编文件中可以由.text、.data和.rodata穿插排布。但在ELF文件中，相同名称的区域布局在一起（**布局信息和具体的文件格式紧密相关**）



