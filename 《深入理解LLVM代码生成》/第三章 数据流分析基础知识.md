# 第三章 数据流分析基础知识

## 3.1 半格、格与不动点

3.1.1 最大下界 最小上界 半格+偏序集定理

3.1.2 偏序关系扩展到格	 完备格（哈斯图），即严格大于小于关系的偏序集，任意子集都有最大下界和最小上界



* **格或者半格的运算属性：**

在满足一定的条件情况下，通过加、乘后 通过函数映射后 仍然是格或者半格

**通过他们的运算属性有效地提高程序分析的精度**



3.1.3 不动点——>f(x) = x（前提是值域和定义域相同）



* 不动点理论可在**编译优化**中求解数据流方程

根据`Knaster-Tarski不动点理论`得知 **完备格上任何单调函数都有一个不动点**：

这意味着在格上寻找一个可处理格中元素的单调函数`f`，就可以到达函数`f`的不动点

**到达不动点则说明计算可以终止了，此时的解就是一个稳定解**



* 如何在完备格中求解不动点，引入上升链和下降链（不严格单增单减的偏序集）

`Kleene不动点定理`

若二元组满足上升链条件，且f(S)=S是S上的单调函数，则f存在一个唯一的最小不动点

若二元组满足下降链条件，且f(S)=S是S上的单调函数，则f存在一个唯一的最大不动点



以上说明了，

单调函数在完备格上至少存在一个最大和最小的不动点；

在满足上升或下降链的情况下，完备格中最小or最大不动点可以进行求解(**即从上下界出发，可通过不断迭代到不动点**)



## 3.2 数据流分析原理及描述

**获取目标数据沿着程序执行路径流动后的最终数据**，数据流分析获取的数据可以用于后续的编译优化

数据流分析不覆盖所有路径及其长度，**实际操作是以CFG节点的所有可能出现的状态信息作为基础进行静态分析，以避免路径爆炸问题**，但这样分析过程**也带来了冗余信息问题，导致计算结果不够精确**（如动态执行时并不会真正执行某些节点，导致本来可以进行优化的操作无法被执行），但较于路径爆炸问题，计算精度稍差是可以被接受的。



3.2.1 根据信息流动的方向，数据流分析分为两类



**前向分析 (Forward Analysis)**

信息流动的方向与程序执行的方向**一致**。

- **方程组**:

  1. **汇合规则**:
     $$
     IN[B] = \bigcup_{P \in \text{predecessors}(B)} OUT[P]
     $$

  2. **转移规则**:
     $$
     OUT[B] = GEN[B] \cup (IN[B] - KILL[B])
     $$

- **经典示例：到达定值分析 (Reaching Definitions Analysis)**

  - **目标**：计算在程序每个点上，可能“到达”此处的变量定义有哪些。
  - **`GEN[d: x = ...]`**: 在当前块中对变量`x`的新定义`d`。
  - **`KILL[d: x = ...]`**: 程序中**所有其他**对变量`x`的定义。因为一个新的赋值会杀死所有关于同一个变量的旧赋值。



**后向分析 (Backward Analysis)**

信息流动的方向与程序执行的方向**相反**。

- **方程组**:

  1. **汇合规则** (与后继块相关):
     $$
     OUT[B] = \bigcup_{S \in \text{successors}(B)} IN[S]
     $$

  2. **转移规则**:
     $$
     IN[B] = GEN[B] \cup (OUT[B] - KILL[B])
     $$

- **经典示例：活跃变量分析 (Live Variable Analysis)**

  - **目标**：计算在程序每个点上，哪些变量的值在未来可能被使用。
  - **`GEN[B]`**: 在块`B`中，那些在被**定义之前就被使用**的变量。
  - **`KILL[B]`**: 在块`B`中，被**赋值（定义）**的变量。因为一次赋值会杀死这个变量之前的旧值。





3.2.2 数据流分析的理论描述

* **格的高度是否有限直接导致了不断迭代能否求到不动点`MFP`**



* **`MOP`是全路径汇合解，其不考虑实际执行路径，只研究了静态可达的所有路径的情况**，因此在精度上更差相较于理想解

  **且`MOP`只在路径的终点才对路径进行聚合**



* 偏序关系：`MFP<=MOP<=Ideal`



## 3.3 数据流方程示例



* 活跃变量

  指的是**一个变量从Def点到Use点之间的区间都是活跃的**

  活跃变量信息是编译优化、代码生成中最为基础的信息:

  **如只有活跃变量才真正需要被分配寄存器，当变量不再活跃后，意味着已经分配给该变量的寄存器可以重用，从而大大提高寄存器分配效率**

  

  求解程序的活跃变量采用**后向分析**，向上记录最后一次使用点，找到定义点

  研究每个基本块的`LiveIn LiveOut LiveUse Def`

  其中`LiveUse` 和 `Def`仅对当前基本块研究不需要计算可以直接给出，而`LiveIn` 和` LiveOut `则需要进行重复计算迭代到不再变化（因为CFG存在循环）才可停止计算
  $$
  LiveOut[B] = \bigcup_{S \in \text{successors}(B)} LiveIn[S]
  $$

$$
LiveIn[B] = USE[B] \cup (LiveOut[B] - DEF[B])
$$



* 到达定值

  **指为程序中使用的变量寻找其定义点，即使用的变量是在哪里定义的**

  其中SSA形式的IR由于包含了Def-Use和Use-Def信息，所以**不需要额外的到达定值分析**；但在非SSA形式的IR中，其可以用在很多编译优化中

​	

​	求解到达定值变量采用前向分析
$$
IN[B] = \bigcup_{P \in \text{predecessors}(B)} OUT[P]
$$

$$
OUT[B] = GEN[B] \cup (IN[B] - KILL[B])
$$

​	此处特别注意`KILL`是指因为重定义而杀死的原来的变量



* 常量传播

​	常量传播是一种最为基础的编译优化手段，它涉及识别并处理形如`int x=5`这样的变量定义

​	若先前识别变量为常量，则在后续内存或寄存器分配中就可以**减少执行的指令、分配的内存或者寄存器，达到程序优化效果**

​	因此为前向分析



​	常量传播并不重新定义任何常量，因此`Kill`为空



​	**在前向数据流分析中，若采用逆后序遍历，可以加速不动点的求解速度：**

​	因为在前向分析中，后续节点的信息来自前驱节点，若前驱节点已经完成访问（信息计算完成），那么后续节点可以直接使用，从而	减少迭代循环次数