# 第9章 基于SSA形式的编译优化

**寄存器分配前的优化主要是基于SSA形式的优化**，寄存器分配后则主要是基于非SSA形式的优化

基于SSA形式的机器指令优化主要包括**尾代码重复、Phi优化、栈着色**等优化

流程如下：

前期尾代码重复——Phi优化——栈着色——栈槽分配——死指令消除——指令并行优化——前期循环不变量外提——公共表达式消除——代码下沉——窥孔优化——死指令消除



* **前期尾代码重复——用于消除指令跳转**，“前期”是指寄存器分配前进行的尾代码重复优化，如果有多个不同的代码路径（例如 `if` 和 `else` 分支），它们最终都汇合到同一块**公共的代码序列（“尾代码”）**，那么我们可以将这段“尾代码”**复制**到每一个分支的末尾，从而**消除**从分支跳转到这个公共代码块的`goto`指令
* **Phi优化——移除两类冗余ø函数**，第一类是死变量插入的ø函数、或者由死变量ø函数构成的循环ø函数，第二类是移除源操作数和目的操作数是同一个寄存器的ø函数（对于部分冗余的情况，则不会进行移除，如`v1 = Φ(v1 from BB1, v2 from BB2)`，其经优化后，在BB1的末尾什么也不做，在BB2的末尾插入 `COPY v1, v2`）
* **栈着色——优化局部变量的布局**，减少栈空间的使用（即让不冲突的局部变量分配同一个栈操来利用栈空间）
* **栈槽分配——将帧索引和栈槽关联在一起**（等价于为栈变量分配栈空间）
* **死指令消除——**根据基本块中的LiveIn、LiveOut信息，从后向前依次遍历MI指令，将死指令删除
* **IPL（指令并行层次）优化——**依赖后端架构的特性进行并行指令优化
* **前期循环不变量外提——将循环不变量提出循环体**，优化循环执行效率，“前期”是指寄存器分配前进行的循环不变量外提
* **公共表达式消除——消除代码中的公共表达式**，减少不必要计算
* **代码下沉——**将分支节点代码下沉到不同分支，本质是将代码执行向后推迟，**可能会因为下沉到的分支不执行而获得执行利益**
* **窥孔优化——**对相邻指令进行局部优化，由于可能会产生新的死代码，所以会再次执行死指令消除操作



## 9.1 前期尾代码重复

原理、如何判断优化收益、如何执行优化

### 9.1.1 尾代码重复原理

**如果两个基本块之间存在跳转指令，那么将后继基本块里的代码提升到前驱基本块中可以移除跳转指令**

当后继基本块中代码较大时会增加代码量，因此LLVM会提供参数`tail-dup-size`来**控制最大重复的指令数**



在寄存器分配前进行优化需要考虑优化对寄存器分配的影响，直观上看将两个基本块的代码合并到一个基本块可能会**增大变量的活跃区间**，从而导致更多的寄存器冲突。因此尾代码重复优化对重复代码进行更多限制，例如对寄存器影响更大的指令如call、ret的代码片段则不允许重复

尾代码重复会影响控制流，所以在进行尾代码优化时对基本块的布局有一定的要求（基本块之间一定存在跳转指令到达的情况）



典型优化场景有2类：

1. **冗余jmp指令优化**
2. **汇聚基本块优化**



### 9.1.2 尾代码收益判断

是否可以对基本块进行尾代码重复优化，主要从优化收益来看：

1. 在特定基本块结构中才能进行尾代码重复

2. **确定最大重复的指令数**，可以通过参数设置`TailDupSize`（默认值为2）实现；

   当要求代码量最小化时，最大重复指令数为1；

   当基本块最后一条指令为间接跳转指令，则最大允许的重复指令数为`TailDupIndirectBranchSize`（默认值为20）

3. **如果有指令明确不可以重复，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isNotDuplicable = true`，表示指令不可重复（例如BPF后端中ret指令不可重复）

4. **如果指令是聚合指令，则放弃执行尾代码重复优化**。在TD文件中设置相关属性`isConvergent = true`，表示指令不可重复（聚合指令和控制流相关，重复代码会导致控制流变化，该属性通常用于GPGPU后端）

5. **如果优化发生在寄存器分配前，且基本块中包含ret、call等指令，则放弃执行尾代码重复优化**。ret指令重复后可能会导致更多的代码“膨胀”（ret重复可能会插入额外的CSR（被调用者保存寄存器）指令；call重复可能会导致更多的寄存器溢出）

6. **如果基本块指令有汇编指令，且包含分支指令，则放弃**。可能会导致逻辑错误

7. 如果基本块中所有指令数超过最大重复指令数，则放弃

8. **如果所有的前驱基本块都包含多个后继基本块，则放弃**。因为重复后，如果前驱基本块走另外路径，则会多执行指令，所以不能重复

9. **如果所有的前驱基本块的最后一条指令不是无条件跳转指令，则放弃**



### 9.1.3 执行尾代码重复优化

尾代码重复优化实现步骤：

1. 对基本块的每一个前驱基本块都尝试进行尾代码合并。当前驱基本块只有一个后继基本块且最后一条指令为无条件跳转指令时开始执行代码重复优化，分为两步：

   1. 删除前驱基本块最后一条无条件跳转指令

   2. 将基本块中的每条指令重复放到前驱基本块中。

      如果是ø函数，指令重复操作本质上是在进行ø函数的析构（在前驱基本块中最后的位置增加COPY指令，并移除ø函数中对应前驱基本块的操作数）；

      示例:

      - 优化前:
        - `P`: ...; `jmp T`
        - `T`: `v3 = Φ(v1 from P, v2 from OtherP)`; ...
      - 优化后 (对 `P` 进行操作):
        - `P`: ...; `COPY v3, v1`; ... (这里是T中其他指令的复制)
        - `T`: `v3 = Φ(v2 from OtherP)`; ... (Φ函数被更新)

      如果是一般指令，则进行代码重复时要保证SSA属性；在SSA形式下，每个虚拟寄存器只能被定义一次

   3. 最后更新CFG图，即移除原来的后继基本块，增加新的后继基本块

2. 如果基本块被重复放到了其全部前驱基本块中，则尝试将基本块也放到其相邻基本块中，之后就可以将基本块移除

   当一个基本块 `T` 的代码，被成功地复制到了它的**所有**前驱基本块中时，一个关键的事情发生了：在控制流图（CFG）中，**不再有任何有效的路径可以跳转到 `T` 的开头**。

   - 所有原来指向 `T` 的跳转，现在都指向了 `T` 原来的后继。
   - `T` 变成了一个不可到达的基本块，即**死代码**

3. 对循环场景需要重构ø函数来做特殊处理。

   ```
   b1
   |
   b2——>exit
   ||
   b3
   ```

   b2 b3 构成一个循环，互为后继基本块。需要在基本块b1 b3 后重复b2 的代码

   b3 中ø函数的源操作数来自b1 和 b3

   ```
   b1
   |
   b2
   |
   b3
   ||
   b2——>exit
   ```

   b3 中ø函数的源操作数来自b2 和 b3，因此还要考虑重构ø函数



## 9.2 Phi 优化