# 第五章 循环基本知识

循环是CFG控制流图的强连通分量子图

根据**循环优化的便利性**可将循环分为 **可归约循环和不可归约循环**

**只有一个入口节点的循环是可归约循环**，单入口的可归约循环**又称自然循环**

LLVM编译器里实现的循环特指自然循环，GCC等也基本上只支持自然循环（原因是大部分循环优化方法仅适用于自然循环，通常对不可归约循环不做优化）



## 5.1 自然循环

**利用第四章的支配关系来解释自然循环的正式定义：**

如果控制流图中存在边的目的节点支配其源节点的情况，则将这条边称为**回边**

**通过支配的定义，这样就可以排除不可归约循环的情况**

**则自然循环的正式定义：假设一条从节点b到节点h的回边，其中h支配b，则可以形成一个可归约循环；如果节点x属于这个自然循环，则满足h支配x，且存在一条可以从x直接到b的路径且路径不经过h**



包含关系的循环——>外循环和内循环



## 5.2 LLVM的循环实现

便于后续分析和变换，需要参考节点**相对循环回边的位置**

为了获取节点位置信息，节点用特殊术语命名如下：

回边源节点——`header`

回边目的节点——`latch`

循环跳出节点，即存在不在循环中的后继节点——`exiting`

便于优化，循环外又定义两种特殊节点——

header节点的前驱——`entering`，如果循环的待进入节点只有一个的话，也称`preheader`

entering在循环外的后继——`exit`



**LLVM IR(包括后端 IR)本身不保存循环信息，所以LLVM将从控制流中获取循环信息的功能作为一个公共分析Pass（记为循环识别Pass），当其他Pass需要循环信息的时候，只需要调用循环识别Pass即可获得**

因此大部分**循环优化Pass**都可以抽象为两步：**先调用循环识别Pass获取循环信息，再对获得的循环进行优化**



LLVM支持多种高级语言循环语法，会产生多种不同的LLVM IR循环形式，因此不利于实现通用的循环优化，所以LLVM提供了3种规范化的循环形式，并实现了相应的转换算法，将统一转换为规范化的循环形式，因此有**循环规范化**这一概念



5.2.1 循环识别

**基于支配树的算法：**首先找到循环的回边**（逆序遍历支配树，对节点N找其前驱节点是否支配自己，即为回边）**，然后利用回边找到循环包含的基本块，从而构造循环，在过程中还会构建循环之间的层级关系。



！！！**利用回边找循环包含的基本块：**

如果N有一到多条回边（多回边是因为内外层嵌套循环），则以N为header节点构建循环，并将所有回边的header放入同一worklist工作链表。之后遍历这个工作链表的节点，判断节点是否属于某个循环，分如下两种情况：

* 如果节点N不属于某个循环，则判为节点N的循环
  * 接着判断是否为N（如果是，则说明已经到了循环头，不需要处理了）。如果不是，则将节点的所有前驱节点加入工作链表worklist（后续还会遍历到，继续判断是不是属于某个循环，此处已经标记判为N的循环了）
* 如果节点已经属于一个循环L，说明存在一个嵌套循环，则找到它的所在的最外层循环。
  * 如果最外层循环就是N的循环，则不需要进一步处理
  * 如果最外层循环不是N的循环，**说明N是一个更大更外层的循环，这是因为逆序遍历N的对应的工作链表节点即N作为header对应的N循环中节点时，发现对应节点又已存在于小循环L中，则N的循环应该是范围更大的外层循环**，则将节点所在的最外层循环作为循环N的子循环，并将所有不在循环L里的前驱节点加入工作链表

**当整个支配树逆序遍历和整个worklist工作链表遍历完成后，就找到了控制流中的所有循环，后续主要是填充各个基本块和循环间的映射关系**





5.2.2 循环规范化

**3种规范化循环形式：**

循环化简形式	循环旋转形式	循环封闭SSA形式



* **循环化简形式：**

循环化简后，循环的形式具有以下3个性质：

1. 有循环的潜质节点，即有且只有一个preheader节点
2. 循环有且只有一条回边
3. 循环专用的exit节点可以被循环的header节点支配，所有exit节点的前驱节点都是循环内的节点

循环化简形式方便做一些循环优化：**循环不变量外提到循环前置节点里和代码下沉到exit节点里**等等



LLVM专门实现了一个Pass，针对循环化简形式的性质设置了以下3个主要功能。**每个功能点都是先判断循环是否符合对应的性质，如果不符合则执行相应的变换，并尝试让其符合**

1. 添加循环前置节点
2. 添加专用的循环退出节点
3. 拆分多回边共用头节点的循环

此外，也具有删除循环中所有不可达基本块等功能



* **循环旋转形式：**

循环的latch节点同时是一个exiting节点（即do-while循环类型）

因为其比循环化简形式更规范化，所以其**也属于循环化简形式**

**循环旋转式擅长外提循环中的“load指令”，也擅长循环向量化**



LLVM提供了一个Pass尝试将化简变为旋转。其迭代地旋转循环中的指令位置，直到将循环变成do-while形式，或者无法再进行位置旋转为止

**为了保持与原始循环语义相同（例如循环体一次都没有执行的情况），会添加一个守卫节点即用来判定循环执行次数的节点**



* **循环封闭 SSA：**

增加额外的约束，即循环中定义的值只在循环中使用，**如果逃逸到循环外，则在循环出口处的基本块插入ø函数**，即LCSSA（循环封闭SSA形式）

```c++
for()
{
	if{
		x1 = 
	}
	else{
		x2 = 
	}
	x3 = ø(x1, x2);
}
... = x3 + 4;


//进行循环封闭SSA形式转换：

for()
{
	if{
		x1 = 
	}
	else{
		x2 = 
	}
	x3 = ø(x1, x2);
}
x4 = ø(x3);
... = x4 + 4;

//此案例中循环出口刚好和x3的使用点位于同一基本块
```

这个ø函数是冗余节点，但在后续优化中可以删除并且其额外引入的ø函数让循环优化更简单

例如，一些**如值范围分析的优化**需要分析出现在循环中定义而在循环外使用的值，刚好就是为了满足LCSSA而创建的ø函数，**所以就不用分析和关注循环了，只需要关注循环出口基本块的ø函数即可**