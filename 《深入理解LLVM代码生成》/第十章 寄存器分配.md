# 第十章 寄存器分配

不同存储介质成本和访问速度不同，采用**层次化存储结构**来让计算机既能高速访问存储又能保持高性价比

程序中定义的访存变量个数远大于寄存器的个数，大多数硬件体系结构在程序执行时总是需要将变量放入寄存器。**将程序执行过程中的访存变量都映射到寄存器中**，这个过程称为**寄存器分配**



LLVM中寄存器分配阶段目的：将MIR中使用的虚拟寄存器映射到目标机器的物理寄存器上

1. 当存在可用的物理寄存器时，将变量映射到物理寄存器中
2. 当没有可用的物理寄存器时，进行**溢出**，即将已经分配寄存器的变量重新放入内存中，得到一个空闲的寄存器，并为当前变量分配寄存器

LLVM中，寄存器分配共**4种分配算法**：

1. **Fast：**默认在O0优化级编译下使用，以**函数为粒度**进行寄存器分配，每个基本块都可以使用全部的物理寄存器。并不考虑变量的活跃区间，遇到变量无法分配的情况则溢出

2. **Basic：**以**函数为粒度**进行寄存器分配，**基于变量活跃区间**进行寄存器分配

   首先对活跃区间按照权重排序

   按照权重**从高到低**逐一分配：

   ​	如果可以为虚拟寄存器分配物理寄存器，则直接分配；

   ​	如果不可以，则选择虚拟寄存器暂存在栈中，并将使用虚拟寄存器的地方重新插入加载指令（从栈中加载数据）

   实验性质的寄存器分配算法，并不用于生产环境中，而是**用于性能基准测试和比较新型寄存器分配算法**

3. **Greedy：**LLVM默认的分配器，以**函数为粒度**进行寄存器分配。和Basic相比，其在寄存器溢出实现上更为复杂，其**目标是生成最小溢出成本的代码**

4. **PBQP：**以**函数为粒度**进行寄存器分配，通过构造一个PBQP来表示寄存器分配问题（**将活跃变量区间等约束转换为方程组**）

   然后通过对PBQP求解来获得结果，再将求解结果映射回寄存器分配



## 10.1 寄存器分配流程解析

寄存器分配需要依赖一些前置Pass，按照实现的依赖特性划分为两类，Fast算法是单独一类，其他三种算法是另一类

### 10.1.1 Fast

`PHI Elimination——>Two Address Instuction——>Fast寄存器分配`

仅依赖以上两个Pass，且不需要依赖变量的生命周期



### 10.1.2 Basic

```
+--------------------------+  +--------------------------+  +--------------------------+
| 寄存器分配的前置依赖Pass |  | Basic算法的独有依赖      |  | 寄存器分配后优化的Pass   |
+==========================+  +==========================+  +==========================+
| Dead和Undef寄存器检测    |  | 调试信息分析             |  | 栈槽着色分配             |
|           ↓              |  |           ↓              |  |           ↓              |
| 隐式定义指令处理         |  | 指令编号                 |  | 寄存器分配后重写处理     |
|           ↓              |  |           ↓              |  |           ↓              |
| 不可达基本块消除         |  | 活跃变量区间分析         |  | 机器复制传播             |
|           ↓              |  |           ↓              |  |           ↓              |
| 活跃变量分析             |  | 寄存器合并               |  | 机器公共子表达式消除     |
|           ↓              |  |           ↓              |  |           ↓              |
| 循环信息分析             |  | 机器指令调度             |  | 机器循环不变代码外提     |
|           ↓              |  |           ↓              |  +--------------------------+
| Phi消除                  |  | 活跃栈变量分析           |
|           ↓              |  |           ↓              |
| 活跃变量区间分析         |  | 别名分析结果使用         |
|           ↓              |  |           ↓              |
| 二地址指令变换           |  | 支配树分析               |
|           ↓              |  |           ↓              |
| 寄存器合并               |  | 循环信息分析             |
|           ↓              |  |           ↓              |
| 无父子寄存器重命名       |  | 虚拟寄存器映射组合信息   |
|           ↓              |  |           ↓              |
| 机器指令调度             |  | Basic寄存器分配算法      |
+--------------------------+  |           ↓              |
                            | 寄存器重写预处理         |
                            |           ↓              |
                            | 虚拟寄存器映射           |
                            |           ↓              |
                            | 寄存器分配评价           |
                            +--------------------------+
```



#### 10.1.2.1 前置依赖分析Pass

1. **Dead 和 Undef 子寄存器检测（`Detect Dead Lane`)**

   对指令进行分析获得子寄存器状态

   **子寄存器**：在CPU中，一个大的物理寄存器通常可以被分解成几个更小的部分来独立访问

   `EAX`, `AX`, `AL` 都是`RAX`的**子寄存器**

   在一些涉及子寄存器使用指令的场景中，指令序列可能存在寄存器死亡或者未定义的情况：

   * 检测到死亡寄存器，其活跃区间变小，更容易合并寄存器；

   * 检测到未定义寄存器，其不用做额外处理，在寄存器分配时选择一个可用的物理寄存器即可；

2. **隐式定义指令处理（`Process Implicit Def`）**

   将所有用到隐式定义的指令的地方设置为Undef（未定义），并且**删除该指令**；在寄存器分配阶段简化**设置为Undef的寄存器**的分配过程

3. **不可达基本块消除（`Unreachable Machine Block Elim`）**

   对MIR进行不可达代码消除，并要保证程序的正确性不被影响，不可达基本块通过分析CFG得到

4. **活跃变量分析（`Live Variables Analysis`）**

   在寄存器分配阶段**仅对活跃变量进行分配**，不活跃变量不需要进行寄存器分配

5. **循环信息分析（`Machine Loop Info`）**

   基于MIR 分析 函数中的循环，循环信息可用于后续的分析和优化Pass（例如基本块频率计算等）

6. **Phi消除（`Phi Elimination`）**

   MIR是SSA形式，存在ø函数，但没有硬件支持ø函数，所以需要将ø函数进行消除才能进行寄存器分配

7. **活跃变量区间分析（`Live Intervals Analysis`）**

   计算活跃变量的生命周期区间，只为生命周期区间内活跃的变量分配寄存器，如果变量不在活跃区间（变量生命周期区间不连续）内，说明此时变量不活跃，不需要进行分配

8. **二地址指令交换（`Two Address Instrucion`）**

   将三地址指令变换为二地址指令，因为一些硬件架构不支持三地址指令，该Pass是否执行取决于TD文件中二地址指令的定义（Constraints属性）

9. **寄存器合并（`Simple Register Coalescing`）**

   对MIR进行寄存器合并处理，指的是将虚拟寄存器在如`%1 = COPY %0`的情况下合并成一个虚拟寄存器，从而减少指令数量和使用的寄存器

10. **无关子寄存器重命名（`Rename Disconnected Independent Subregister`）**

    可能存在多个独立使用的子寄存器

    将子寄存器对应的虚拟寄存器重命名，以减少寄存器压力（为子寄存器分配不同的物理寄存器，以减少寄存器溢出的概率）

    该优化只适用于部分后端，只有在后端支持子寄存器，且子寄存器可以联合使用的场景才有意义

11. **机器指令调度（`Machine Instruction Scheduler`）**

    分析MIR中的数据依赖，按照指令调度算法对MIR重新排序，主要是为了减少寄存器压力



#### 10.1.2.2 不同分配算法依赖的Pass（Basic 为例）

1. **调试信息分析（`Debug Variables Analysis`）**

   因为寄存器分配时不会处理调试相关指令，防止影响寄存器分配

   * 在寄存器分配之前找到调试指令，并记录调试指令的作用域（即指令的活跃区间），然后删除调试指令

   * 在寄存器分配之后，根据调试指令的作用域重新插入调试指令（新插入的调试指令会使用已经分配的物理寄存器替换原指令的虚拟寄存器）

2. **指令编号（`Slot Indexe Analysis`）**

   为指令进行编号，指令的编号在活跃区间中使用

3. **活跃变量区间分析（`Live Interval Analysis`）**

   计算活跃变量的生命周期区间，供寄存器分配使用

4. **寄存器合并（`Simple Register Coalescing`）**

   对MIR进行寄存器合并处理，主要是为了优化ø函数以及二地址指令变换引入的大量COPY指令

5. **机器指令调度（`Machine Instruction Scheduler`）**

   分析MIR中的数据依赖，并按照指令调度算法重新对MIR进行排序

6. **活跃栈变量分析（`Live Stack Slot Analysis`）**

   栈变量是指在溢出时被放入栈空间临时存放的变量，该Pass不需分析活跃变量，**只需分配数据结构，来记录寄存器溢出后虚拟寄存器和栈变量的映射信息即可**

7. **别名分析结果使用（`Alias Analysis Results Wrapper`）**

   使用别名分析的结果，确保移动后的指令正确（若指令使用的变量产生别名，则需在指令移动时确保变量不冲突）

8. **支配树分析（`Machine Dominator Tree`）**

   基于MIR 分析 函数中的支配树信息

   支配树不仅仅在循环信息分析中被使用，在后续多个Pass中也会被使用（例如移动指令时）

9. **循环信息分析（`Machine Natural Loop Analysis`）**

   基于MIR 分析 函数中的循环

10. **虚拟寄存器映射（`Virtual Register Map`）**

    记录寄存器分配过程中虚拟寄存器和物理寄存器之间的映射关系，分配之后进行虚拟寄存器的重写时会使用到这个信息

    不需要对指令进行真正分析，而**仅需分配相关数据结构的内存，用于记录寄存器分配过程中二者的映射关系**

11. **活跃寄存器组合信息（`Live Register Matrix`）**

    **记录虚拟寄存器分配信息**，包含了映射和溢出的栈位置信息，供分配之后虚拟寄存器重写使用

12. **Basic寄存器分配算法（`Basic Register Allocator`）**

    为指令中使用的虚拟寄存器分配物理寄存器，如果遇到无法分配的情况，**还需要选择合适的虚拟寄存器溢出到栈空间**

13. **寄存器重写预处理（`Hook point for PreRewrite`）**

    为不同的后端**提供挂载点**，**允许后端在寄存器映射之前做特殊处理**

14. **寄存器映射（`Virtual Register Rewritter`）**

    虚拟寄存器映射为物理寄存器，并重写指令

15. **寄存器分配评价（`Register Allocation Scoring`）**

    评价方式：计算寄存器分配后的各种指令的总成本，并在计算过程中为**不同的指令设置不同的权重**

    通过机器学习不断迭代以获取最优的寄存器分配结果



#### 10.1.2.3 分配后依赖的Pass

1. 栈槽着色分配（`Stack Slot Coloring`）

   遇到寄存器溢出情况，需要用到栈空间暂存变量

   如果两个栈变量的活跃区间不重叠，则可以重用一个栈槽空间

2. 寄存器分配后重写处理（`Hook Point for PostRewrite`）

   为不同的后端提供挂载点，允许后端在寄存器映射之后进行独有的处理

3. 机器复制传播（`Machine Copy Propagation`）

   在寄存器分配之后，会引入少量COPY指令，经过COPY指令的复制传播优化可以消除

4. 循环不变量外提（`Machine LICM`）

   在寄存器分配之后再次执行循环不变量外提，可能是机器复制传播等Pass执行后出现了新的优化机会



### 10.1.3 依赖 Pass 分类

1. 适用于所有后端的Pass：
   * 修改原始MIR或者生成新MIR的转换类Pass，例如ø函数消除、二地址指令转换等
   * 为寄存器分配算法运行提供用于数据分析的分析类Pass，例如指令编号、活跃变量区间分析
   * 用于资源分配的Pass，例如活跃栈变量分析、寄存器映射，机器指令调度等
2. 适用于部分后端的Pass：



## 10.2 寄存器分配涉及的Pass

