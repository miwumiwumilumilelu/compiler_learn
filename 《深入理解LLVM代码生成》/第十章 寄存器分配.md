# 第十章 寄存器分配

不同存储介质成本和访问速度不同，采用**层次化存储结构**来让计算机既能高速访问存储又能保持高性价比

程序中定义的访存变量个数远大于寄存器的个数，大多数硬件体系结构在程序执行时总是需要将变量放入寄存器。**将程序执行过程中的访存变量都映射到寄存器中**，这个过程称为**寄存器分配**



LLVM中寄存器分配阶段目的：将MIR中使用的虚拟寄存器映射到目标机器的物理寄存器上

1. 当存在可用的物理寄存器时，将变量映射到物理寄存器中
2. 当没有可用的物理寄存器时，进行**溢出**，即将已经分配寄存器的变量重新放入内存中，得到一个空闲的寄存器，并为当前变量分配寄存器

LLVM中，寄存器分配共**4种分配算法**：

1. **Fast：**默认在O0优化级编译下使用，以**函数为粒度**进行寄存器分配，每个基本块都可以使用全部的物理寄存器。并不考虑变量的活跃区间，遇到变量无法分配的情况则溢出

2. **Basic：**以**函数为粒度**进行寄存器分配，**基于变量活跃区间**进行寄存器分配

   首先对活跃区间按照权重排序

   按照权重**从高到低**逐一分配：

   ​	如果可以为虚拟寄存器分配物理寄存器，则直接分配；

   ​	如果不可以，则选择虚拟寄存器暂存在栈中，并将使用虚拟寄存器的地方重新插入加载指令（从栈中加载数据）

   实验性质的寄存器分配算法，并不用于生产环境中，而是**用于性能基准测试和比较新型寄存器分配算法**

3. **Greedy：**LLVM默认的分配器，以**函数为粒度**进行寄存器分配。和Basic相比，其在寄存器溢出实现上更为复杂，其**目标是生成最小溢出成本的代码**

4. **PBQP：**以**函数为粒度**进行寄存器分配，通过构造一个PBQP来表示寄存器分配问题（**将活跃变量区间等约束转换为方程组**）

   然后通过对PBQP求解来获得结果，再将求解结果映射回寄存器分配



## 10.1 寄存器分配流程解析

寄存器分配需要依赖一些前置Pass，按照实现的依赖特性划分为两类，Fast算法是单独一类，其他三种算法是另一类

### 10.1.1 Fast

`PHI Elimination——>Two Address Instuction——>Fast寄存器分配`

仅依赖以上两个Pass，且不需要依赖变量的生命周期



### 10.1.2 Basic

```
+--------------------------+  +--------------------------+  +--------------------------+
| 寄存器分配的前置依赖Pass |  | Basic算法的独有依赖      |  | 寄存器分配后优化的Pass   |
+==========================+  +==========================+  +==========================+
| Dead和Undef寄存器检测    |  | 调试信息分析             |  | 栈槽着色分配             |
|           ↓              |  |           ↓              |  |           ↓              |
| 隐式定义指令处理         |  | 指令编号                 |  | 寄存器分配后重写处理     |
|           ↓              |  |           ↓              |  |           ↓              |
| 不可达基本块消除         |  | 活跃变量区间分析         |  | 机器复制传播             |
|           ↓              |  |           ↓              |  |           ↓              |
| 活跃变量分析             |  | 寄存器合并               |  | 机器公共子表达式消除     |
|           ↓              |  |           ↓              |  |           ↓              |
| 循环信息分析             |  | 机器指令调度             |  | 机器循环不变代码外提     |
|           ↓              |  |           ↓              |  +--------------------------+
| Phi消除                  |  | 活跃栈变量分析           |
|           ↓              |  |           ↓              |
| 活跃变量区间分析         |  | 别名分析结果使用         |
|           ↓              |  |           ↓              |
| 二地址指令变换           |  | 支配树分析               |
|           ↓              |  |           ↓              |
| 寄存器合并               |  | 循环信息分析             |
|           ↓              |  |           ↓              |
| 无父子寄存器重命名       |  | 虚拟寄存器映射组合信息   |
|           ↓              |  |           ↓              |
| 机器指令调度             |  | Basic寄存器分配算法      |
+--------------------------+  |           ↓              |
                            | 寄存器重写预处理         |
                            |           ↓              |
                            | 虚拟寄存器映射           |
                            |           ↓              |
                            | 寄存器分配评价           |
                            +--------------------------+
```



#### 10.1.2.1 前置依赖分析Pass

1. **Dead 和 Undef 子寄存器检测（`Detect Dead Lane`)**

   对指令进行分析获得子寄存器状态

   **子寄存器**：在CPU中，一个大的物理寄存器通常可以被分解成几个更小的部分来独立访问

   `EAX`, `AX`, `AL` 都是`RAX`的**子寄存器**

   在一些涉及子寄存器使用指令的场景中，指令序列可能存在寄存器死亡或者未定义的情况：

   * 检测到死亡寄存器，其活跃区间变小，更容易合并寄存器；

   * 检测到未定义寄存器，其不用做额外处理，在寄存器分配时选择一个可用的物理寄存器即可；

2. **隐式定义指令处理（`Process Implicit Def`）**

   将所有用到隐式定义的指令的地方设置为Undef（未定义），并且**删除该指令**；在寄存器分配阶段简化**设置为Undef的寄存器**的分配过程

3. **不可达基本块消除（`Unreachable Machine Block Elim`）**

   对MIR进行不可达代码消除，并要保证程序的正确性不被影响，不可达基本块通过分析CFG得到

4. **活跃变量分析（`Live Variables Analysis`）**

   在寄存器分配阶段**仅对活跃变量进行分配**，不活跃变量不需要进行寄存器分配

5. **循环信息分析（`Machine Loop Info`）**

   基于MIR 分析 函数中的循环，循环信息可用于后续的分析和优化Pass（例如基本块频率计算等）

6. **Phi消除（`Phi Elimination`）**

   MIR是SSA形式，存在ø函数，但没有硬件支持ø函数，所以需要将ø函数进行消除才能进行寄存器分配

7. **活跃变量区间分析（`Live Intervals Analysis`）**

   计算活跃变量的生命周期区间，只为生命周期区间内活跃的变量分配寄存器，如果变量不在活跃区间（变量生命周期区间不连续）内，说明此时变量不活跃，不需要进行分配

8. **二地址指令交换（`Two Address Instrucion`）**

   将三地址指令变换为二地址指令，因为一些硬件架构不支持三地址指令，该Pass是否执行取决于TD文件中二地址指令的定义（Constraints属性）

9. **寄存器合并（`Simple Register Coalescing`）**

   对MIR进行寄存器合并处理，指的是将虚拟寄存器在如`%1 = COPY %0`的情况下合并成一个虚拟寄存器，从而减少指令数量和使用的寄存器

10. **无关子寄存器重命名（`Rename Disconnected Independent Subregister`）**

    可能存在多个独立使用的子寄存器

    将子寄存器对应的虚拟寄存器重命名，以减少寄存器压力（为子寄存器分配不同的物理寄存器，以减少寄存器溢出的概率）

    该优化只适用于部分后端，只有在后端支持子寄存器，且子寄存器可以联合使用的场景才有意义

11. **机器指令调度（`Machine Instruction Scheduler`）**

    分析MIR中的数据依赖，按照指令调度算法对MIR重新排序，主要是为了减少寄存器压力



#### 10.1.2.2 不同分配算法依赖的Pass（Basic 为例）

1. **调试信息分析（`Debug Variables Analysis`）**

   因为寄存器分配时不会处理调试相关指令，防止影响寄存器分配

   * 在寄存器分配之前找到调试指令，并记录调试指令的作用域（即指令的活跃区间），然后删除调试指令

   * 在寄存器分配之后，根据调试指令的作用域重新插入调试指令（新插入的调试指令会使用已经分配的物理寄存器替换原指令的虚拟寄存器）

2. **指令编号（`Slot Indexe Analysis`）**

   为指令进行编号，指令的编号在活跃区间中使用

3. **活跃变量区间分析（`Live Interval Analysis`）**

   计算活跃变量的生命周期区间，供寄存器分配使用

4. **寄存器合并（`Simple Register Coalescing`）**

   对MIR进行寄存器合并处理，主要是为了优化ø函数以及二地址指令变换引入的大量COPY指令

5. **机器指令调度（`Machine Instruction Scheduler`）**

   分析MIR中的数据依赖，并按照指令调度算法重新对MIR进行排序

6. **活跃栈变量分析（`Live Stack Slot Analysis`）**

   栈变量是指在溢出时被放入栈空间临时存放的变量，该Pass不需分析活跃变量，**只需分配数据结构，来记录寄存器溢出后虚拟寄存器和栈变量的映射信息即可**

7. **别名分析结果使用（`Alias Analysis Results Wrapper`）**

   使用别名分析的结果，确保移动后的指令正确（若指令使用的变量产生别名，则需在指令移动时确保变量不冲突）

8. **支配树分析（`Machine Dominator Tree`）**

   基于MIR 分析 函数中的支配树信息

   支配树不仅仅在循环信息分析中被使用，在后续多个Pass中也会被使用（例如移动指令时）

9. **循环信息分析（`Machine Natural Loop Analysis`）**

   基于MIR 分析 函数中的循环

10. **虚拟寄存器映射（`Virtual Register Map`）**

    记录寄存器分配过程中虚拟寄存器和物理寄存器之间的映射关系，分配之后进行虚拟寄存器的重写时会使用到这个信息

    不需要对指令进行真正分析，而**仅需分配相关数据结构的内存，用于记录寄存器分配过程中二者的映射关系**

11. **活跃寄存器组合信息（`Live Register Matrix`）**

    **记录虚拟寄存器分配信息**，包含了映射和溢出的栈位置信息，供分配之后虚拟寄存器重写使用

12. **Basic寄存器分配算法（`Basic Register Allocator`）**

    为指令中使用的虚拟寄存器分配物理寄存器，如果遇到无法分配的情况，**还需要选择合适的虚拟寄存器溢出到栈空间**

13. **寄存器重写预处理（`Hook point for PreRewrite`）**

    为不同的后端**提供挂载点**，**允许后端在寄存器映射之前做特殊处理**

14. **寄存器映射（`Virtual Register Rewritter`）**

    虚拟寄存器映射为物理寄存器，并重写指令

15. **寄存器分配评价（`Register Allocation Scoring`）**

    评价方式：计算寄存器分配后的各种指令的总成本，并在计算过程中为**不同的指令设置不同的权重**

    通过机器学习不断迭代以获取最优的寄存器分配结果



#### 10.1.2.3 分配后依赖的Pass

1. 栈槽着色分配（`Stack Slot Coloring`）

   遇到寄存器溢出情况，需要用到栈空间暂存变量

   如果两个栈变量的活跃区间不重叠，则可以重用一个栈槽空间

2. 寄存器分配后重写处理（`Hook Point for PostRewrite`）

   为不同的后端提供挂载点，允许后端在寄存器映射之后进行独有的处理

3. 机器复制传播（`Machine Copy Propagation`）

   在寄存器分配之后，会引入少量COPY指令，经过COPY指令的复制传播优化可以消除

4. 循环不变量外提（`Machine LICM`）

   在寄存器分配之后再次执行循环不变量外提，可能是机器复制传播等Pass执行后出现了新的优化机会



### 10.1.3 依赖 Pass 分类

1. 适用于所有后端的Pass：
   * 修改原始MIR或者生成新MIR的转换类Pass，例如ø函数消除、二地址指令转换等
   * 为寄存器分配算法运行提供用于数据分析的分析类Pass，例如指令编号、活跃变量区间分析
   * 用于资源分配的Pass，例如活跃栈变量分析、寄存器映射，机器指令调度等
2. 适用于部分后端的Pass：



## 10.2 寄存器分配涉及的Pass

### 10.2.1 死亡和未定义子寄存器检测

识别到死亡的寄存器可以不再分配物理寄存器；而未定义的寄存器则可以使用任意一个物理寄存器

```
%0 = soe definition
%1 = IMPLICIT_DEF
%2 = REG_SEQUENCE %0, sub0, %1, sub1
%3 = EXTRACT_SUBREG %2, sub1
	 = use %3
```

* 死亡寄存器检测：

  * 后向数据流分析

  * 没有被使用的寄存器则认为死亡，所以先识别使用中的寄存器，即**寄存器使用信息分析**

    * 从出口指令开始，%3被其他指令使用，所以%3使用的寄存器%2应该是活跃的
    * 但%3仅使用了%2的sub1部分，而%2是由 REG_SEQUENCE 指令定义的%0和%1构成，%0没有被使用，因此%0是死亡的

  * 本质是**活跃变量分析**的数据流方程

    `LiveIn(i)`: 在指令 `i` 执行前保持活跃的寄存器（及其子寄存器部分）

    `LiveOut(i)`: 在指令 `i` 执行后保持活跃的寄存器（及其子寄存器部分）

    `Use(i)`: 指令 `i` 读取的寄存器（及其子寄存器部分）

    `Def(i)`: 指令 `i` 写入的寄存器（及其子寄存器部分）

    * 基本块内传递方程:
      $$
      LiveIn(i) = Use(i) \cup (LiveOut(i) - Def(i))
      $$
      在一条指令之前是活跃的，要么是这条指令本身要用它，要么是它在指令之后也是活跃的且没有被这条指令覆盖

    * 指令间传递:
      $$
      LiveOut(i) = \bigcup_{s \in succ(i)} LiveIn(s)
      $$
      `succ(i)`: 指令 `i` 的所有后继指令

  * 例子分析：

    **`= use %3`**:

    - 这是分析的起点。这条指令使用了 `%3`
    - 因此，在它之前，`%3` 必须是活跃的
    - `LiveIn(use)` = `{%3:all}` (假设 `%3` 的所有位都被使用)

    **`%3 = EXTRACT_SUBREG %2, sub1`**:

    - 这条指令的 `LiveOut` 就是其后继 `use` 指令的 `LiveIn`。所以 `LiveOut` = `{%3:all}`
    - $Use$ = `{%2:sub1}` (只使用了 `%2` 的 `sub1` 部分)
    - $Def$ = `{%3:all}` (定义了整个 `%3`)
    - 应用基本块内传递方程
    - **结论**: 在这条指令之前，只有 `%2` 的 `sub1` 部分是活跃的

    **`%2 = REG_SEQUENCE %0, sub0, %1, sub1`**:

    - 这条指令的 `LiveOut` 是其后继 `EXTRACT_SUBREG` 指令的 `LiveIn`。所以 `LiveOut` = `{%2:sub1}`

    - $Use$ = `{%0:all, %1:all}`

    - $Def$ = `{%2:all}`

    - **分析死亡定义**: 这里的关键是判断定义 `Def` 是否真的“活”到了 `LiveOut`

      - `REG_SEQUENCE` 指令定义了 `%2` 的两个部分：`%2:sub0` (来自`%0`) 和 `%2:sub1` (来自`%1`)。
      - 我们检查 `LiveOut` 集合 `{%2:sub1}`。
      - `%2` 的 `sub1` 部分在 `LiveOut` 中，所以定义 `sub1` 的源操作数 `%1` 是**活的**。
      - `%2` 的 `sub0` 部分**不在** `LiveOut` 中，所以定义 `sub0` 的源操作数 `%0` 是**死的**。

      

* 未定义寄存器检测：

  * 前向数据流分析
  * 使用了隐式定义操作数的寄存器实际上是未定义的，即**寄存器定义信息分析**
    * %0被显示定义
    * %1是隐式定义
    * %2由两个寄存器构成，其中sub1是隐式定义
    * %3仅由%2的sub1部分构成，是隐式定义，这样的隐式定义就是未定义的
  * 本质是**到达定义分析**的数据流方程
    * 略

数据流方程具体参考3.3.1 & 3.3.2



### 10.2.2 隐式定义指令处理

隐式定义的寄存器一般是MIR中未定义的指令，在寄存器分配时需要将这些隐式定义指令删除，避免被其他指令使用

进行以下处理：

1. 如果隐式定义指令定义的寄存器是虚拟寄存器，则将Def-Use链中Use的MO（机器指令操作数）设置为`Undef`状态，同时对类COPY指令进行**复制传播优化**，即递归处理MO的定义寄存器（**传播`Undef`状态**）

   标记了所有使用点，定义点冗余了，然后删除该隐式定义指令

2. 如果隐式定义指令定义的寄存器为物理寄存器，如Def-Use链中Use的寄存器是Def的寄存器或子寄存器，则将Use的寄存器设置为Undef状态，然后删除该指令

3. **如果机器指令中所有MO即操作数都是未定义的，则删除该指令**

   相当于把垃圾搬到了垃圾堆，把垃圾堆删掉

因为隐式定义指令会被删除，而死亡和未定义子寄存器检测需要根据隐式定义信息计算出Undef状态的子寄存器，所以需要先执行死亡和未定义子寄存器检测，然后再执行隐式定义指令删除



### 10.2.3 不可达MBB消除

识别不可达MBB：

​	遍历CFG时，只要**能从Entry开始遍历到的MBB都是可达的**，遍历不到的就是不可达的

不可达的MBB属于**死代码**，当发现不可达MBB时，需要将其删除

如果不可达MBB属于循环，则删除MBB会影响循环结构，所以需要**在删除不可达MBB时 需要更新支配信息、循环结构以及影响的ø函数**



### 10.2.4 活跃变量分析

多个后续Pass直接依赖活跃变量分析，例如寄存器分配类Pass只针对活跃变量进行分配

活跃变量分析需要先找到那些在一条指令结束后立即无效（Dead）的寄存器集合，还需要找出那些在当前指令中使用，但执行这条指令后不再使用的寄存器集合（被当前指令杀死）

对虚拟寄存器和物理寄存器进行何时死亡、何时被杀死进行分析

**活跃变量分析不需要计算寄存器的Def和Use信息，因为MIR是SSA形式，天然包含这些信息**



LLVM采用**不动点算法，前向数据流分析**



规则如下：

1. 寄存器的活跃信息使用一个集合保存，在集合中存放的是MBB，表示寄存器在整个MBB都是活跃的
2. **如果寄存器在同一个MBB中定义和使用，在MBB外不再活跃，则不会存放在该集合中**？？？
3. 我们使用一个集合保存寄存器被杀死的信息，在集合中**存放的信息形式是MIR**，表示寄存器在此MIR后不会在被使用

3. **如果ø函数是最后使用寄存器的指令，这条ø函数不会出现在保存杀死信息的集合中**

4. 如果寄存器在同一个MBB中被定义和使用，并且仅在后继基本块的ø函数中被再次使用，则会出现寄存器活跃集合为空，同时寄存器的杀死信息集合也为空的情况

   这是因为寄存器在MBB的最后一条指令仍然都是活跃的，但是在进入后继基本块后不再活跃



实现：

1. 以函数为粒度，依次处理每个MBB中的基本块

2. 遍历MBB中每条机器指令，收集指令中的Def和Use寄存器，**如果是ø函数，仅仅收集Def寄存器**

3. 对所有的Use寄存器进行处理：

   * 通过不动点方式遍历虚拟寄存器前驱基本块
   * 将其前驱基本块加入寄存器的活跃集合中，直到遍历所有的前驱基本块
   * 物理寄存器则还需额外处理其子寄存器

4. 对所有的EC寄存器进行处理：处理物理寄存器可能发生EC的情况

5. 对所有的Def寄存器进行处理：

   虚拟寄存器默认先定义后使用，使用以后寄存器会被杀死

   （所以需要先处理Use，这样保证最后杀死的信息总是指向最后一条指令）

   物理寄存器也类似处理其子寄存器

**对于机器指令出现的物理寄存器处理稍微不同：**

1. 在指令选择过程中会生成MBB的LiveIn和LiveOut，二者主要是物理寄存器

   LiveIn通常是放置在寄存器中的函数参数

   LiveOut通常是放置在寄存器中的返回值

   在活跃区间分析时，我们通常会设定一个虚拟指令来定义LiveIn值；如果基本块最后一条指令是return，那么它将被标记为具有LiveOut属性

   LiveIn和LiveOut集合会影响活跃变量的计算

2. 假设物理寄存器只在单一的基本块上存活，则针对局部进行分析

3. 有些物理寄存器不是可分配的（例如栈指针寄存器和条件码寄存器），这些寄存器不会被分析，只在指令选择阶段进行构建

4. 物理寄存器在处理Def和Use时需要考虑子寄存器情况



### 10.2.5 Phi 消除

