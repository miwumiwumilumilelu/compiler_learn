# 第八章 指令调度

一个典型的流水线**取指令——>译码——>执行——>回写**四个阶段

假设每个阶段是一个时钟周期，单CPU从第一周期开始会不断进行取指令，从第二周期开始会不断进行译码，第三周期开始会不断进行执行，第四周期开始会不断进行回写。也就是说每个单元都会从第五周期开始进入满荷负载工作状态，不断地执行一条条指令

但是4个单元刚好能存下一个指令的所有阶段，**所以平均下来一条指令只需一个时钟周期，CPU性能在引入流水线后提升近3倍**

流水线本质是**空间换时间**，不同指令各步并行操作，从而实现CPU各单元的并行处理



但前提是各个指令之间没有依赖。若有依赖关系，则需要等待上一条指令回写

LLVM中常见3种依赖：1. data(数据依赖)，当前操作数是上一条指令输出结果 2. chain(链依赖)，固定访存操作顺序 3. glue(铰链依赖),指令序列在调度时不能被分开



指令调度的**作用就是通过调整指令的顺序，减少指令间依赖对流水线的影响**



* 根据调度发生阶段：
  1. 动态调度：发生在**运行时**，需要相应的硬件支持——处理器会在运行时对指令序列进行重排，**并乱序地发送到处理器功能单元**，以便处理器能够同时处理更多的指令
  2. 静态调度：发生在**编译阶段**——对指令进行重排，消除指令间依赖，提升指令并行度（本书只关注静态调度）
* 根据指令调度的工作范围：
  1. 局部调度：针对单基本块进行调度，适用于所有后端
  2. 全局调度：跨多个基本块进行调度
  3. 循环调度：针对循环体内的基本块进行指令调度优化，这主要是针对软流水的优化，目前仅适用于ARM、PPC、Hexagon后端