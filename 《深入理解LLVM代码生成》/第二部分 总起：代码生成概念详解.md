# 第二部分 代码生成概念详解

**代码生成是编译器后端的统称**

代码生成模块非常复杂，但**通过LLVM的模块化设计，将不同的功能设计为不同的Pass，然后进行组合**，以完成代码生成



**代码生成的逻辑如下：**

> LLVM——>指令选择——>指令调度-1——>编译优化-1——>寄存器分配——>前言/后序代码生成
>
> ——>编译优化-2——>指令调度-2——>其他优化——>机器码发射——>机器码

* **指令选择：**
  * 为LLVM IR选择合适的机器指令
  * LLVM实现了三种指令选择算法，目前LLVM后端默认使用的是`基于DAG的SelectionDAGISel`指令选择算法
    * 在指令选择阶段引入图IR，并使用图匹配的方法为LLVM IR生成**MIR（面向后端的机器中间表示）**，**虽然MIR的结构与后端无关，但是大部分MIR的操作码和具体后端相关**，少部分则如伪指令
* **指令调度-1:**
  * 根据MIR中的数据依赖对指令进行调度
  * 指令选择阶段也有指令调度，图中未体现
  * LLVM支持表调度和循环调度等
  * **此时的优化也称为Pre-RA调度，目的在于减少寄存器分配过程中的压力**
* **编译优化-1:                 预寄存器分配调度 (Pre-Register Allocation Scheduling)**
  * **基于SSA形式的MIR进行编译优化**，例如进行死代码删除和公共表达式消除等优化
* **寄存器分配：**
  * 将MIR中使用的逻辑寄存器映射到物理寄存器
  * LLVM支持Fast、Basic、Greedy、PBQP
  * 可通过命令参数regalloc指定
* **前言/后序代码生成：**
  * 为函数生成前言和后序代码，例如处理栈帧布局等
* **编译优化-2:**
  * **经过寄存器分配后的MIR为非SSA形式，可在进行一次编译优化，如复制传播优化等**
  * 与编译优化-1即基于SSA形式的**优化思路相同**，但因MIR不再具有SSA特点，**优化算法实现有所不同**
* **指令调度-2:                后寄存器分配优化与调度 (Post-Register Allocation Optimization & Scheduling)**
  * 此时优化也称为Post-RA调度，此时，所有指令和寄存器都已确定，调度器会根据目标CPU的微架构特性（如流水线深度、指令延迟、端口资源等），对指令进行重排序，以最大化指令级并行，最小化CPU停顿
  * 目的在于**提高执行效率**
* **其他优化：**
  * 执行机器码发射前的优化
  * 此处允许**后端自主实现特殊的优化**，如执行基本块重排等优化
* **机器码发射：**
  * **寄存器分配完成后就可以进入机器码发射阶段（真正生成目标机器代码）**
  * LLVM引入MCInst IR ，更好地处理JIT，汇编，反汇编代码





**Pass的执行顺序可能导致机器码质量不同，因此需要根据场景需求，对Pass顺序进行调整生成高质量机器码**

**代码生成过程中的一些Pass不重要，则可以关闭其中的Pass来获得更好的性能**