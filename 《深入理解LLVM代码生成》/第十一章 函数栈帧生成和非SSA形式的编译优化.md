# 第十一章 函数栈帧生成和非SSA形式的编译优化

主要讨论在寄存器分配后、代码生成前所做的工作

1. 函数的栈帧生成及其相关优化
2. 针对MIR的编译优化
3. 指令变换和调度
4. 机器码生成前优化

此时做的优化不再考虑寄存器压力等因素，因为寄存器已经分配完毕



## 11.1 函数栈帧生成及其相关优化

函数栈帧生成——为满足后端调用约定，**在函数调用时为函数生成执行栈**，以确保程序执行的正确性

在函数栈帧最终确定前可以进行代码下沉和栈帧范围收缩优化

### 11.1.1 栈帧生成

栈帧生成的最重要的3个任务：

1. 对CSR进行处理：这是达到调用约定所需的最主要工作之一
2. 完成栈帧布局：在栈帧布局确定之前，通过栈索引来访问栈对象（假定栈对象存放在一个数组中）；当栈帧布局确定后，可基于栈寄存器的偏移来访问栈对象
3. 函数前言/后序生成：前言通常是为函数建立新的栈帧，后序则是为了销毁函数栈帧

主要工作如下：

1. 计算Save、Restore位置，默认Save和Restore分别位于函数的入口和函数的出口（函数的出口可能有多个，所以每个出口位置都需要进行栈帧销毁）

   当栈帧范围收缩时，可以重新调整Save、Restore位置

2. 根据后端约定计算函数使用的CSR（需要遍历函数，**函数中修改的CSR才需要保存**）以及为CSR分配对应栈槽，如果函数没有使用CSR则不需要分配栈槽

3. 在Save和Restore基本块中为需要保存的CSR插入COPY指令，用于保存和恢复CSR，同时更新路径中CSR影响到的基本块

4. 根据栈使用的方向、对齐粒度等，为栈对象计算真实的偏移值

5. 插入函数的前言和后序代码，**主要是为了保存和恢复栈寄存器**

6. 将栈对象的偏移值和栈寄存器关联，栈对象则可以都通过栈寄存器访问得到



### 11.1.2 代码下沉

LLVM共有4个代码优化，两个在中端，一个在基于SSA形式MIR的寄存器分配前，一个在基于非SSA形式MIR的寄存器分配后

此时为基于非SSA形式MIR的寄存器分配后阶段，**LLVM仅会尝试下沉COPY指令**，可能会在后续的栈帧范围收缩或者复制传播环节带来新的优化机会

* 接下来介绍允许代码下沉场景：

  当前基本块的COPY指令定义的寄存器

  1. 在当前基本块的唯一后继基本块中活跃
  2. 有两个后继基本块，且其中一个唯一活跃
  3. 有两个基本块，其中一个后继基本块的后继基本块是当前节点，构成一个循环，且其中一个唯一活跃

* 禁止代码下沉的场景：

  当前基本块的COPY指令定义的寄存器

  1. 有两个后继基本块，且同时活跃
  2. 有两个后继基本块，且它们的后继汇聚同一个基本块D，这两个后继都不活跃，但在基本块D中活跃
  3. 其后继基本块有多个前驱，有可能执行来自于其他分支

**代码下沉算法**

以基本块为粒度进行处理

1. **从下往上**依次遍历基本块的指令，遇到Call指令时终止下沉（无法确定Call之前的指令是否会受到Call指令影响），然后处理下一个基本块

2. 当指令不是COPY，通过记录指令定义和使用的寄存器来处理下一条指令

3. 如果是COPY，当COPY定义的**寄存器不可以重命名时**（不可重命名的寄存器一般是为了满足后端约束而指定的寄存器），通过记录指令定义和使用的寄存器来处理下一条指令

4. 判断COPY指令是否和已经遍历的指令**存在寄存器依赖**，如果当前COPY指令中定义的寄存器被后序的指令（已经遍历过的指令）使用或重新定义，则不能下沉，需要转而处理下一条指令

5. 经过前4步判断处理，COPY可能可以下沉了，还需要为下沉的COPY指令寻找一个基本块

   对COPY指令定义的寄存器进行分析，根据之前介绍情况进行判定

   下沉或者继续处理下一条

6. 一般来说，下沉到基本块的第一条指令处。但如果存在调用约定前序指令，那么下沉COPY指令不能和相关指令的寄存器存在读写依赖，则进行特殊处理

7. **COPY指令下沉后需要更新下沉基本块的LiveIn信息，将COPY指令定义的寄存器从LiveIn中删除（此寄存器会在下沉基本块中重新定义），并将COPY指令使用的寄存器增加到LiveIn中**（也就是当前基本块COPY定义的寄存器，不再是下一个基本块的LiveIn了，而是在下一个基本块中才定义）

**中后端代码下沉比较**

|          下沉方式          | 功能                                                         |
| :------------------------: | :----------------------------------------------------------- |
|          **Sink**          | 属于中端优化，针对有多个后继节点的基本块（分支和循环）进行下沉优化。代码下沉后，有的分支可能不再被执行，从而达到减少代码执行的效果。除了特殊指令（指调用函数、边界指令、异常指令等）外，其他代码在中端优化都可以进行下沉，下沉时寻找一个位置，该位置能支配所有Use下沉指令。目前，在LLVM中执行中端代码下沉时，如果目的基本块中存在关键边，则不会对关键边拆分（如果不进行关键边拆分，则会导致代码错误），直接放弃下沉。 |
|       **Loop Sink**        | 属于中端优化，针对循环进行代码下沉。是和中端优化LICM相反的优化动作。在对循环代码下沉时，为了保证进行中的代码下沉不增加代码的执行成本，只会选择执行频率低的基本块作为下沉目的地，同时要求下沉目的地的执行成本小于循环头的执行成本，否则不会进行下沉。 |
|    **Machine Sinking**     | 属于后端优化，针对有多个后继节点的基本块（分支和循环）进行下沉。通过代码下沉，有的分支可能不再被执行，从而可以减少代码的执行。它并不是中端优化Sink的替代，而是其补充。 |
| **PostRA Machine Sinking** | 属于后端优化，仅仅针对COPY指令下沉，以帮助复制传播和栈帧收缩产生新的优化机会。 |



### 11.1.3 栈帧范围收缩