# 第十一章 函数栈帧生成和非SSA形式的编译优化

主要讨论在寄存器分配后、代码生成前所做的工作

1. 函数的栈帧生成及其相关优化
2. 针对MIR的编译优化
3. 指令变换和调度
4. 机器码生成前优化

此时做的优化不再考虑寄存器压力等因素，因为寄存器已经分配完毕



## 11.1 函数栈帧生成及其相关优化

函数栈帧生成——为满足后端调用约定，**在函数调用时为函数生成执行栈**，以确保程序执行的正确性

在函数栈帧最终确定前可以进行代码下沉和栈帧范围收缩优化

### 11.1.1 栈帧生成

栈帧生成的最重要的3个任务：

1. 对CSR进行处理：这是达到调用约定所需的最主要工作之一
2. 完成栈帧布局：在栈帧布局确定之前，通过栈索引来访问栈对象（假定栈对象存放在一个数组中）；当栈帧布局确定后，可基于栈寄存器的偏移来访问栈对象
3. 函数前言/后序生成：前言通常是为函数建立新的栈帧，后序则是为了销毁函数栈帧

主要工作如下：

1. 计算Save、Restore位置，默认Save和Restore分别位于函数的入口和函数的出口（函数的出口可能有多个，所以每个出口位置都需要进行栈帧销毁）

   当栈帧范围收缩时，可以重新调整Save、Restore位置

2. 根据后端约定计算函数使用的CSR（需要遍历函数，**函数中修改的CSR才需要保存**）以及为CSR分配对应栈槽，如果函数没有使用CSR则不需要分配栈槽

3. 在Save和Restore基本块中为需要保存的CSR插入COPY指令，用于保存和恢复CSR，同时更新路径中CSR影响到的基本块

4. 根据栈使用的方向、对齐粒度等，为栈对象计算真实的偏移值

5. 插入函数的前言和后序代码，**主要是为了保存和恢复栈寄存器**

6. 将栈对象的偏移值和栈寄存器关联，栈对象则可以都通过栈寄存器访问得到



### 11.1.2 代码下沉

LLVM共有4个代码优化，两个在中端，一个在基于SSA形式MIR的寄存器分配前，一个在基于非SSA形式MIR的寄存器分配后

此时为基于非SSA形式MIR的寄存器分配后阶段，**LLVM仅会尝试下沉COPY指令**，可能会在后续的栈帧范围收缩或者复制传播环节带来新的优化机会

* 接下来介绍允许代码下沉场景：

  当前基本块的COPY指令定义的寄存器

  1. 在当前基本块的唯一后继基本块中活跃
  2. 有两个后继基本块，且其中一个唯一活跃
  3. 有两个基本块，其中一个后继基本块的后继基本块是当前节点，构成一个循环，且其中一个唯一活跃

* 禁止代码下沉的场景：

  当前基本块的COPY指令定义的寄存器

  1. 有两个后继基本块，且同时活跃
  2. 有两个后继基本块，且它们的后继汇聚同一个基本块D，这两个后继都不活跃，但在基本块D中活跃
  3. 其后继基本块有多个前驱，有可能执行来自于其他分支

**代码下沉算法**

以基本块为粒度进行处理

1. **从下往上**依次遍历基本块的指令，遇到Call指令时终止下沉（无法确定Call之前的指令是否会受到Call指令影响），然后处理下一个基本块

2. 当指令不是COPY，通过记录指令定义和使用的寄存器来处理下一条指令

3. 如果是COPY，当COPY定义的**寄存器不可以重命名时**（不可重命名的寄存器一般是为了满足后端约束而指定的寄存器），通过记录指令定义和使用的寄存器来处理下一条指令

4. 判断COPY指令是否和已经遍历的指令**存在寄存器依赖**，如果当前COPY指令中定义的寄存器被后序的指令（已经遍历过的指令）使用或重新定义，则不能下沉，需要转而处理下一条指令

5. 经过前4步判断处理，COPY可能可以下沉了，还需要为下沉的COPY指令寻找一个基本块

   对COPY指令定义的寄存器进行分析，根据之前介绍情况进行判定

   下沉或者继续处理下一条

6. 一般来说，下沉到基本块的第一条指令处。但如果存在调用约定前序指令，那么下沉COPY指令不能和相关指令的寄存器存在读写依赖，则进行特殊处理

7. **COPY指令下沉后需要更新下沉基本块的LiveIn信息，将COPY指令定义的寄存器从LiveIn中删除（此寄存器会在下沉基本块中重新定义），并将COPY指令使用的寄存器增加到LiveIn中**（也就是当前基本块COPY定义的寄存器，不再是下一个基本块的LiveIn了，而是在下一个基本块中才定义）

**中后端代码下沉比较**

|          下沉方式          | 功能                                                         |
| :------------------------: | :----------------------------------------------------------- |
|          **Sink**          | 属于中端优化，针对有多个后继节点的基本块（分支和循环）进行下沉优化。代码下沉后，有的分支可能不再被执行，从而达到减少代码执行的效果。除了特殊指令（指调用函数、边界指令、异常指令等）外，其他代码在中端优化都可以进行下沉，下沉时寻找一个位置，该位置能支配所有Use下沉指令。目前，在LLVM中执行中端代码下沉时，如果目的基本块中存在关键边，则不会对关键边拆分（如果不进行关键边拆分，则会导致代码错误），直接放弃下沉。 |
|       **Loop Sink**        | 属于中端优化，针对循环进行代码下沉。是和中端优化LICM相反的优化动作。在对循环代码下沉时，为了保证进行中的代码下沉不增加代码的执行成本，只会选择执行频率低的基本块作为下沉目的地，同时要求下沉目的地的执行成本小于循环头的执行成本，否则不会进行下沉。 |
|    **Machine Sinking**     | 属于后端优化，针对有多个后继节点的基本块（分支和循环）进行下沉。通过代码下沉，有的分支可能不再被执行，从而可以减少代码的执行。它并不是中端优化Sink的替代，而是其补充。 |
| **PostRA Machine Sinking** | 属于后端优化，仅仅针对COPY指令下沉，以帮助复制传播和栈帧收缩产生新的优化机会。 |



### 11.1.3 栈帧范围收缩

指的是**优化函数前言和后序的位置**，以便降低执行成本

一般来说，函数前言插入在entry基本块中，函数后序插入在一个或多个返回基本块中

并非最优，可以进行插入优化

**Save (序言)**：位于代码执行的**上游**。为了保证安全，它必须位于所有CSR使用点**之前**（支配它们）

**Restore (结语)**：位于代码执行的**下游**。为了保证安全，它必须位于所有CSR使用点**之后**（逆支配它们）

**实现：**

1. 针对基本块，以**PROT顺序遍历**基本块中的每一条指令，保证优先遍历叶子节点
   1. 如果指令没有使用CSR或者栈对象，则处理下一条指令
   2. 否则说明基本块是候选的函数前言/后序的插入位置，可以尝试更新save、restore指令的位置，依赖于以下判定：
      * save应该支配基本块，所以save会更新为**支配当前基本块和原来save**的基本块（第一次执行save为空时，直接赋值当前基本块）
      * restore应该逆支配基本块，所以restore会更新为**逆支配当前基本块和原来store**的基本块
      * save也应该支配restore，否则save应该更新为支配原来save和restore的基本块
      * restore也应该逆支配save，否则restore应该更新为逆支配save和原来restore的基本块
      * 如果save和restore处于循环中，他们应该位于同一个循环体
2. 当处理完所有基本块后，得到最后的save和restore，save和restore的执行成本应该低于entry基本块、exit基本块的执行成本，否则还需要更新save和restore，更新方法如下：
   1. 如果save的基本块的执行成本高于entry，**将save中的基本块更新为支配所有前驱的基本块**，同时要求基本块的执行成本低于entry基本块的执行成本
   2. 如果restore的基本块的执行成本高于exit，**将restore中的基本块更新为逆支配所有后驱的基本块**，同时要求基本块的执行成本低于exit基本块的执行成本

**上述实现算法的限制：**

1. 算法尽可能地寻找唯一的save/restore执行点，分别用于存放函数前言和后序，复杂的函数结构计算得到的save和restore中保存的基本块与entry/exit基本块的执行成本相同
2. 算法并未针对CSR、栈操作分别处理，也导致丧失优化机会



## 11.2 MIR 优化

在寄存器分配完成后执行的MIR优化有3个

1. **分支折叠**：通过优化跳转基本块的位置、MIR指令提升等来消除跳转指令
2. **尾代码重复**：将基本块中的代码提升到前驱基本块中，以便消除额外的跳转指令
3. **复制传播**：对COPY指令进行优化，消除冗余复制



### 11.2.1 分支折叠

分支折叠最早出现在硬件设计中，其目的是避免流水线被中断

通过将一些分支指令进行重排，从而达到消除跳转指令或者重排指令后不再中断流水线执行的效果



**分支折叠分为：**

1. **尾代码合并**：与尾代码重复相反，执行与否取决于后端，**如果后端允许修改CFG则可以执行，否则不能执行**

   1. 情况1:将函数中没有后继基本块的基本块（即出口）进行合并

      在所有可以合并的基本块中取尾代码重复最多的基本块，然后合并

      * 合并时会创建一个新的基本块（取尾代码重复的代码到这个统一的基本块中，即将相同代码放置在新的基本块中）
      * 然后设置其中一个位置相邻基本块与新创建的基本块前驱后继的直通关系（不需要跳转指令），另一个基本块则新增无条件跳转指令
      * 再观察新建基本块中放入的重复代码是否与其他未处理的基本块的尾代码继续重复，则继续重复以上操作进行尾代码合并

   2. 情况2:将基本块的多个前驱基本块进行合并

      同情况1一样，都是新建基本块来存重复尾代码，进行合并

      **其中考虑到一种场景：当前基本块T与其前驱基本块B不是位置相邻，而是通过条件跳转得到即不是直通关系——则可以尝试调整其前驱基本块位置，使其相邻（将条件跳转指令的条件逻辑进行反转，使其不会直接跳转到当前基本块T，而是跳转到B原本直通的基本块D，也就是我们可以插入新的基本块AB进来作为基本块B现在的直通），将基本块A和B中的相同指令再合并到基本块AB中，最后AB指向当前基本块T**

      即`if (条件成立)` **跳去 T**；`else` **直通 D** 转变为`if (条件成立)` **跳去 D**；`else` **直通 AB**

   实际上，尾代码合并有诸多细节：

   1. 计算基本块是否可以合并时，不仅仅考虑相同指令数，还会考虑其他因素，用于判断合并后是否有收益，收益可以通过针对场景的分析得到：
      * 两个基本块有部分相同的指令，同时一个基本块被另一个基本块包含（有后继关系，**且后继基本块的指令完全包含在另外一个基本块中**），进行代码合并不仅可以减少代码，还不需要创建新的基本块
      * 当代码合并开启后，如果待合并的相同指令数较少时（通常**阈值**为两条指令，可以通过设置参数来执行**激进的合并**，以减少代码），会**要求两个基本块都在冷路径**中（如果基本块都在热路径中，为热路径增加跳转指令会影响执行效率）
   2. 对于要划分的基本块，目前是找一个执行成本最低的基本块进行划分（这样做相对公平）；对基本块进行划分，**新产生的基本块应该继承所有前驱基本块的执行频率**
   3. 更新新增的基本块的LiveIn等信息

   

2. **基本块优化**：包括死基本块删除、空基本块消除和相同分支基本块合并等

   1. 空基本块消除

      需要保证基本块的相邻关系，而不用引入额外指令

   2. 相同分支基本块合并

      如果br cond两种分支都指向同一个基本块，则可以将分支条件移除（删除`br cond`）

      * 如果两个基本块相邻，则直接删除分支指令，进行直通
      * 如果不相邻，则增加无条件跳转指令（在后续分支折叠中还可以尝试移除该指令进行优化）

   3. 基本块压缩

      要求基本块相邻，且后继基本块的前驱只有一个，则后继基本块中的指令完全可以移入前驱基本块中

   4. 条件分支移除

      如果在基本块中，条件分支指令只在一个分支中存在，而另一个分支为空，则可以移除分支指令或者将其替换为无条件跳转指令

   5. 条件分支的条件化简和反转

      注意冷热代码分离，所以可以考虑通过条件反转来调整代码位置即基本块位置（减少条件跳转的假分支直通的约束即位置相邻的约束）

   6. 连续跳转指令合并

      对于连续跳转的基本块优化后，如果是死基本块则进行删除

      该优化执行约束比较多，可能带有副作用，如若放置跳转指令的基本块是热路径时，经过这样优化会影响后续代码布局，导致性能问题

   7. 循环中条件分支的条件反转

      **因为真分支预测执行效率更高，可以获得更高的执行性能收益**，所以让真分支作为循环体

   8. 无条件跳转指令消除

      我感觉和基本块压缩差不多，如果存在仅包含无条件跳转指令的基本块，则将其删除，并检查前驱基本块是否直通其跳转的基本块，注意为前驱添加跳转指令

      这里注意，假设有基本块A与该基本块相邻，但并不是前驱，需要格外注意重构基本块A的最后分支指令，使基本块A执行完可以跳转到正确的后继基本块中，避免直通该基本块

   9. 调整基本块相邻位置

      如果遍历基本块的顺序，发现存在优化机会，则可以调整基本块的位置，以消除分支指令

      向上调整，让当前基本块与其前驱基本块进行位置相邻；或向下调整，让当前基本块与其后继基本块进行位置相邻

   10. 删除死基本块（没有前驱的基本块除了entry块）

       删除死基本块不仅删除它本身，还会删除其后继基本块

       

3. **代码提升**：将公共代码向上提升，减少代码大小

   在基本块的多个后继基本块中提取公共代码并进行公共代码提升（上移）

   注意约束细节：

   * 代码提升一定会放在基本块的所有跳转指令之前（条件分支指令之前）

     **若跳转指令会修改、使用寄存器，且提升的代码的寄存器和其存在依赖关系**，则不能进行提升，避免产生错误跳转

   * 代码提升不仅要求两个分支基本块中的指令相同，还要求**指令的一些属性也应该相同**，如dead，killed会影响寄存器的生命周期

     如果不同则不能提升

   * 被提升的指令**需要更新的指令状态**，保证状态的正确设置

   * 被提升的指令应该是需要**能安全移动**的（例如volatile类型的内存访问指令一般是不安全的，call指令的移动一般也是不完全的）

   * 代码提升后，还需要**保证两个分支基本块的LiveIn等信息正确**

4. **跳表优化**：针对跳表进行优化

   switch-case优化，对没有使用的跳表项进行移除



### 11.2.2 尾代码重复

虽然会增加代码量，但可能会为后续复制传播优化提高更多机会；同时，与9.1节介绍的相比，**此时执行尾代码重复的限制更少**，可以处理call、ret指令，且不要求MIR保持SSA形式，实现更为简单



### 11.2.3 复制传播

与10.2.14介绍的完全相同，后端进行优化过程中产生了COPY指令，所以这里再次进行复制传播优化了



## 11.3 MIR指令变换和调度