### **第1章 绪论 (Introduction)**



本章的目标是建立对LLVM的宏观认知，理解其设计理念与生态构成。



#### **1.1 LLVM设计思想剖析**



- **核心是“模块化”与“可重用”**：LLVM被设计成一系列可独立使用的库，而不是一个庞大的单体程序。
- **三段式架构**：这是LLVM设计的基石，将编译过程清晰解耦。
  1. **前端**：负责将源代码（如C++）转换为统一的、与具体硬件无关的**LLVM IR**。
  2. **优化器**：接收IR，并对IR进行各种优化，此阶段不关心源码是什么语言，也不关心目标是什么硬件。
  3. **后端**：将优化后的IR转换为特定硬件平台（如x86、ARM）的机器码。
- **LLVM IR作为核心**：IR是整个架构的“窄腰”（Narrow Waist），它作为通用的中间语言，解耦了前端和后端，使得任意M种语言和N种硬件平台的编译器开发工作量从 M×N 降低为 M+N。



#### **1.2 LLVM主要子项目**



- **Clang**：LLVM官方的C、C++、Objective-C前端。它不仅是编译器，其内部的库（如libclang）也为许多IDE和静态分析工具提供了支持。
- **LLVM Core (核心库)**：包含了LLVM IR的数据结构定义、Pass管理器以及大量的优化算法实现，是优化器的主要载体。
- **llc**：LLVM的静态编译器（后端工具），负责将LLVM IR文件（`.ll`或`.bc`）编译成目标平台的汇编文件。
- **lli**：LLVM的即时编译器（JIT），可以直接解释和执行LLVM IR，常用于开发和调试。
- **lld**：LLVM项目的高性能链接器，旨在替代系统默认的`ld`链接器。
- **lldb**：LLVM项目的原生调试器。



#### **1.3 LLVM的编译与调试**



- **为何要源码编译**：要深入研究LLVM、开发自己的优化Pass或为新硬件编写后端，必须从源码编译，以便进行单步调试和定制开发。
- **编译配置**：介绍了不同的编译类型，主要是`Debug`（包含完整的调试信息，便于调试但运行慢）和`Release`（经过充分优化，运行快但难以调试）的区别。



#### **1.4 LLVM在线工具**



- **Compiler Explorer (godbolt.org)**：这是一个极其有用的在线网站，可以实时查看输入的C++（或其他语言）代码被不同版本的Clang/GCC编译后，所生成的LLVM IR以及最终的汇编代码。
- **作用**：它为学习和理解编译过程提供了即时反馈，是快速验证代码生成行为、对比优化效果的绝佳工具。

------



### **第2章 IR基础知识 (Basics of IR)**



本章深入LLVM的技术核心，详细讲解作为编译器工作语言的IR。



#### **2.1 IR的分类**



- **2.1.1 树状IR (Tree IR)**：通常指**抽象语法树（AST）**。
  - **特点**：结构与源代码高度一致，保留了完整的语法结构。
  - **用途**：非常适合进行语法检查、语义分析和类型检查，但其层次结构不便于进行需要分析程序流的优化。
- **2.1.2 线性IR (Linear IR)**：通常指**三地址码**。
  - **特点**：是一种扁平的、类似汇编的指令序列，每条指令最多有三个操作数。
  - **用途**：结构简单，便于进行指令级的优化，但丢失了程序的高级控制流结构（如循环、分支结构都变成了`if-goto`）。
- **2.1.3 图状IR (Graph IR)**：LLVM IR采用的形式。
  - **特点**：结合了前两者的优点。它将程序表示为**控制流图（CFG）**，图的节点（基本块）内部是线性的IR指令。
  - **优势**：既保留了高级的控制流信息（图结构），又便于进行指令级的分析（块内指令），是进行各类优化的理想形态。



#### **2.2 基本块与CFG的构建**



- **基本块 (Basic Block)**：是构成CFG的原子单位。它是一段最长的、只有一个入口（第一条指令）和一个出口（最后一条指令，通常是跳转或返回）的连续指令序列。
- **控制流图 (Control Flow Graph, CFG)**：是一个有向图。图的**节点**是基本块，**有向边**代表了基本块之间可能的跳转关系。CFG是所有数据流分析和优化的基础数据结构。



#### **2.3 静态单赋值 (Static Single Assignment, SSA)**



- **2.3.1 SSA基本概念**：
  - **核心规则**：每个变量在程序中只被赋值一次。
  - **实现方式**：当原始代码对同一变量多次赋值时，SSA形式会通过**重命名**创建出不同的版本（如 `x` 变成 `x_1`, `x_2` 等）。
  - **核心优势**：使得变量的“定义-使用关系”（Def-Use Chain）变得异常清晰和直接，极大地简化了编译器的优化算法。
- **2.3.2 SSA的构建与析构**：
  - **构建**：编译器使用基于“统治边界”（Dominance Frontier）的算法，来自动判断应该在哪些控制流汇合点为哪些变量插入Φ函数，从而将代码转为SSA形式。
  - **析构**：由于真实硬件没有Φ指令，在代码生成的最后阶段，编译器需要消除SSA形式，这个过程通常是在Φ函数的各个前驱块末尾插入等价的`move`指令来完成。
- **2.3.3 SSA的分类**：
  - **Minimal SSA (最小SSA)**：根据统治边界算法，在所有逻辑上需要合并变量值的地方都插入Φ函数。
  - **Pruned SSA (剪枝SSA)**：是最小SSA的优化。如果在某个汇合点插入的Φ函数所定义的变量，在后续路径中从未被使用过（即变量是“死的”），那么这个Φ函数就是多余的。剪枝SSA会结合“活性分析”来避免插入这种无用的Φ函数。
- **2.3.4 基本块参数与Φ节点 (Φ Node)**：
  - **Φ节点**：是实现SSA的关键机制。它是一个特殊的伪指令，必须放在基本块的起始位置。
  - **功能**：它根据控制流的**来源路径**（即从哪个前驱基本块跳转而来），来选择使用对应路径上的变量版本。例如 `x_3 = Φ( [x_1, %label_A], [x_2, %label_B] )` 表示如果从`label_A`块来，`x_3`的值就是`x_1`；如果从`label_B`块来，值就是`x_2`。



#### 2.4 Briggs-Cooper 算法 (SSA构建与剪枝)



**目标**：高效地构建**剪枝SSA（Pruned SSA）**形式。

“剪枝”意味着只在**绝对必要**的地方插入Φ函数，避免产生无用的Φ节点，从而生成更简洁、更利于分析的IR。

**背景问题：朴素的Φ函数放置算法 (Cytron et al.)** 最早的SSA构建算法基于**统治边界（Dominance Frontier）**。其规则是：

> 如果一个基本块 `B` 中存在对变量 `V` 的定义，那么就在 `B` 的所有统治边界节点上都为 `V` 插入一个Φ函数。

这个算法是正确的，但**过于激进**。它可能会在一个变量已经“死亡”（后续不会再被使用）的路径汇合点插入一个无用的Φ函数。

**Briggs算法的核心思想：结合活性分析 (Liveness Analysis)**

Briggs算法的精髓在于，它认为：

> 只有当一个变量 `V` 的值能够“存活”着到达一个控制流汇合点时，才有必要为它插入Φ函数。

因此，它在朴素算法的基础上增加了一个**剪枝步骤**：在决定是否要在统治边界节点 `F` 处为变量 `V` 插入Φ函数之前，先检查 `V` 在 `F` 的入口处是否是**活跃（Live）**的。如果不活跃，则无需插入。



假设我们有以下代码：

C

```
// B1
int x = 1;
int y = 5;
if (cond) {
    // B2
    y = 10;
} else {
    // B3
    // y 没有被修改
}
// B4 (汇合点)
return x;
```

**步骤 1: 构建CFG和统治边界**

- **CFG**:
- **变量定义**: `x` 在 `B1` 定义，`y` 在 `B1` 和 `B2` 定义。
- **统治边界**: `B1` 和 `B2` 的统治边界都是 `{B4}`。

**步骤 2: 活性分析 (Liveness Analysis)**

我们逆向分析变量在何处是活跃的。

- `x` 在 `B4` 被使用（`return x`），所以 `x` 在 `B4` 入口处是**活跃**的，并向上追溯到 `B1`。
- `y` 在 `B4` 以及之后的任何地方都**未被使用**，所以 `y` 在 `B4` 的入口处是**不活跃（死亡）**的。

**步骤 3: 放置Φ函数**

现在我们来决定 `B4` 需要为哪些变量放置Φ函数。

- **对于变量 `x`**:
  - `B1` 中有 `x` 的定义。
  - `B4` 在 `B1` 的统治边界中。
  - **Briggs检查**: `x` 在 `B4` 的入口处是**活跃**的吗？**是的**。
  - **结论**: 需要为 `x` 插入Φ函数。但由于只有一条路径 (`B1`) 对 `x` 进行了赋值，实际上优化器会简化掉这个看似无用的Φ函数。
- **对于变量 `y`**:
  - `B1` 和 `B2` 中有 `y` 的定义。
  - `B4` 在 `B1` 和 `B2` 的统治边界中。
  - **朴素算法**: 会不假思索地在 `B4` 为 `y` 插入一个Φ函数: `y_3 = Φ(y_1 from B2, y_2 from B3)`。
  - **Briggs检查**: `y` 在 `B4` 的入口处是**活跃**的吗？**不是**。
  - **结论**: **剪枝！** 不需要为 `y` 插入Φ函数。

**结果对比**

- **朴素SSA**:

  ```
  B4:
    x_2 = Φ(x_1 from B2, x_1 from B3)
    y_3 = Φ(y_2 from B2, y_1 from B3) // <-- 无用的Φ函数
    return x_2
  ```

- **Briggs剪枝SSA**:

  ```
  B4:
    x_2 = Φ(x_1 from B2, x_1 from B3)
    // y_3 的Φ函数被剪枝了
    return x_2
  ```

通过这种方式，Briggs算法生成了更干净、更高质量的SSA IR。

------



#### 2.5 Sreedhar 算法 (SSA析构)



**目标**：将程序从SSA形式转换回普通的机器指令形式，核心是**消除Φ函数**。

**背景问题：简单的替换为何行不通？** 一个看似简单的方法是：对于 `y = Φ(x1 from P1, x2 from P2)`，在 `P1` 结尾加上 `y = x1`，在 `P2` 结尾加上 `y = x2`。但在某些情况下，这会导致严重的问题。

1. **丢失拷贝问题 (Lost-Copy Problem)**：当一个块内的多个Φ函数互相依赖时，简单的拷贝顺序会导致错误。
2. **关键边问题 (Critical Edge Problem)**：如果一个前驱块 `P` 有多个后继块，而后继块 `S` 有多个前驱块，那么边 `P -> S` 就是一条“关键边”。我们不能简单地在 `P` 的末尾插入拷贝指令，因为这会影响到 `P` 的其他后继。

**Sreedhar算法的核心思想：拆分关键边，并用临时变量打破拷贝依赖**

该算法系统性地解决了上述问题。

**步骤 1: 拆分关键边 (Split Critical Edges)**

这是消除Φ函数的前提。算法会遍历CFG，在每一条关键边 `P -> S` 中间插入一个新的空基本块 `B_new`，将 `P -> S` 变为 `P -> B_new -> S`。这样，原本要插入到边上的拷贝指令就有了一个专属的存放位置 (`B_new`)。

**步骤 2: 消除Φ函数并插入拷贝**

在所有关键边都被拆分后，就可以安全地将Φ函数转换为其前驱块末尾的拷贝指令了。

**步骤 3: 解决丢失拷贝问题**

考虑以下在一个块 `B` 开头的Φ函数：

```
B:
  x_2 = Φ(y_1 from P1, ...)
  y_2 = Φ(x_1 from P1, ...)
```

我们想在前驱块 `P1` 的末尾插入 `x_2 = y_1` 和 `y_2 = x_1`。

- 如果执行 `x_2 = y_1; y_2 = x_1;`，`y_2` 会得到 `y_1` 的值，而不是原始 `x_1` 的值。**这是丢失拷贝！**
- 如果执行 `y_2 = x_1; x_2 = y_1;`，也会出现同样的问题。

这实际上是一个**变量交换** (`swap`) 的问题。Sreedhar的算法通过构建一个拷贝的**依赖图**来检测这种**循环依赖**。

- **依赖图**: 对于 `a=b`，画一条从 `b` 到 `a` 的边。

- **检测**: 上述例子会产生一个环: `y_1 -> x_2` 和 `x_1 -> y_2`。如果 `x_1` 和 `x_2`、`y_1` 和 `y_2` 最终要分配到同一个位置，这就构成了一个 `x <-> y` 的环。

- **解决**: 当检测到环时，通过引入一个**临时变量 `tmp`** 来打破它。

  ```
  // 在 P1 末尾
  tmp = x_1
  x_2 = y_1
  y_2 = tmp
  ```

Sreedhar的算法提供了一套完整的流程来识别所有并行的拷贝指令，检测其中的依赖环，并以最少的临时变量来正确地实现它们。

- **Briggs-Cooper 算法**作用于**SSA构建**阶段，它通过**活性分析**来**剪枝**，避免生成无用的Φ函数，是一种**优化**的构建方法。
- **Sreedhar 算法**作用于**SSA析构**阶段，它通过**拆分关键边**和**解决拷贝依赖**，来安全、正确地将Φ函数**消除**，转换成能在物理机上执行的线性代码。