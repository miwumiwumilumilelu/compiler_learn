# 第七章 指令选择

**将高级语言映射成目标架构指令**的过程称为指令选择

映射可能一对一，也可能多对一



指令选择需要解决模式匹配和模式选择两个子问题

**模式匹配：**单指令匹配、树匹配、DAG匹配和图匹配

**模式选择：**以最短运行时间和最小内存开销为目标

处理方式：

1. **分开处理：**先匹配后选择，**可以取到最优**

2. **两阶段合并处理：(启发式算法) **一边匹配一边判断是否为当前最优，最终可以得到**一个相对好的匹配结果，处理时间较前一种更短**



## 7.1 指令选择的处理流程

1. 指令选择模块在后端实现，但它并不是后端第一个Pass，而在其之前还会进行LLVM IR的相关工作：
   1. **进一步降低LLVM IR 和后端IR的语义差异**，方便后续进行后端IR的变换
   2. **进行一些功能的处理**，如异常处理和`inrinsic`处理
2. 指令选择执行完成之后，**还会有`Finalize Isel`的过程来完成指令选择相关的一些事情**

综上所述，将指令选择分为3个阶段：**指令选择预处理阶段、指令选择阶段、指令选择后处理阶段**



* 指令选择预处理阶段相关Pass：
  * `PreISelIntrinsicLowering`：**对LLVM内置函数进行降级——即将一个高级、抽象的内置函数，转换为一个由更简单、更基础的IR指令组成的等价实现，或者直接转换成一个对标准库函数的调用**
    * 将两类`inrinsic`指令（LLVM内部定义的特殊指令），以及`llvm.load.relative` 和 `llvm.objc.*`分别转换为相应的LLVM IR指令
  * `ExpandLargeDivRem`：**由于硬件能力限制无法支持超过目标架构可用位数长度的除法或者取余操作，故将其展开，转换成可用位数范围内的除法或者取余替代指令。当前最小支持位数是32位**
  * `CodeGenPrepare`: **主要用于配置元数据和对LLVM IR进行窥孔优化**
  * `ExceptionHandling`: **用于生成异常处理代码，根据不同的异常约定生成相应的代码。如果不需要支持异常，则此Pass不需开启**
  * `IselPrepare`: **主要是两个栈安全相关的功能实现——安全栈和栈保护，用于防止栈溢出或栈被破坏带来的安全漏洞**
* 指令选择阶段：**将LLVM IR 翻译成MIR**
* 指令选择后处理阶段：
  * `Finalize Isel`：**指令选择之后紧跟的Pass，有些目标架构自定义的伪指令会在这个阶段展开成机器指令**



**LLVM后端支持多芯片指令集导致了多后端冗余问题**——即多种指令集之间会存在相似的指令，如果每个架构都分开独立地去翻译这些指令，就会产生很多冗余的代码

**因此相关指令选择算法采取引入新的中间表示（共享框架）来进行LLVM IR到MIR的过渡**（如DAG IR 和 GMIR）



## 7.2 SelectionDAGISel 算法分析

局部指令选择算法，**以函数中的基本块为粒度，不考虑跨基本块的指令处理，只针对基本块内的LLVM IR生成最优的MIR指令**

算法实现将指令分成两类处理：

1. 以基本块为粒度，对基本块内的指令（忽略ø函数）进行指令选择
2. 针对ø函数处理基本块之间的关系，在基本块完成指令选择之后，再为基本块之间重构汇聚关系（再次添加ø函数）



1.第一类处理

**SelectionDAGISel针对基本块进行指令选择流程：**

**LLVM IR先初始化（紧跟合并优化），后进行类型合法化（紧跟合并优化）、向量合法化、类型合法化（紧跟合并优化）、操作合法化（紧跟合并优化）的合法化操作，最后进行指令选择、指令调度和MIR发射得到最终MIR**

* 其中**合并优化**基本都是一些窥孔优化：**目的是清理上一环节可能产生的冗余DAG表达，用单个节点替换同功能的多个节点组合，减轻下一个环节需要处理的节点数量**
* **类型合法化**执行了两次：**第一次是对所有的节点类型进行处理，确保处理后的数据类型都是后端架构可以支持的，然后判断基于这些数据类型的操作是否合法**；**第二次则是因为合法化处理过程中，可能会重新产生架构不支持的数据类型**，因此需要再一次处理，对新产生的数据类型清理干净

2.第二类处理

基本块之间的ø函数处理：基本块内指令处理完毕后即处理到最后一条LLVM IR即Terminator指令，**根据CFG获取后继基本块的第一条指令**。若该指令是ø函数，说明后继基本块需要重**构ø函数依赖，编译器会先记录如ø函数位置、使用变量等相关信息，在所有基本块都执行完指令选择后再重构ø函数**



引入DAG数据结构，采用SDnode节点，**抽象指令格式为一组操作码和操作数，以此屏蔽不同处理器架构和指令集之间的差异**



