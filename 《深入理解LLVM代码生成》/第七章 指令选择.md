# 第七章 指令选择

**将高级语言映射成目标架构指令**的过程称为指令选择

映射可能一对一，也可能多对一



指令选择需要解决模式匹配和模式选择两个子问题

**模式匹配：**单指令匹配、树匹配、DAG匹配和图匹配

**模式选择：**以最短运行时间和最小内存开销为目标

处理方式：

1. **分开处理：**先匹配后选择，**可以取到最优**

2. **两阶段合并处理：(启发式算法) **一边匹配一边判断是否为当前最优，最终可以得到**一个相对好的匹配结果，处理时间较前一种更短**



## 7.1 指令选择的处理流程

1. 指令选择模块在后端实现，但它并不是后端第一个Pass，而在其之前还会进行LLVM IR的相关工作：
   1. **进一步降低LLVM IR 和后端IR的语义差异**，方便后续进行后端IR的变换
   2. **进行一些功能的处理**，如异常处理和`inrinsic`处理
2. 指令选择执行完成之后，**还会有`Finalize Isel`的过程来完成指令选择相关的一些事情**

综上所述，将指令选择分为3个阶段：**指令选择预处理阶段、指令选择阶段、指令选择后处理阶段**



* 指令选择预处理阶段相关Pass：
  * `PreISelIntrinsicLowering`：**对LLVM内置函数进行降级——即将一个高级、抽象的内置函数，转换为一个由更简单、更基础的IR指令组成的等价实现，或者直接转换成一个对标准库函数的调用**
    * 将两类`inrinsic`指令（LLVM内部定义的特殊指令），以及`llvm.load.relative` 和 `llvm.objc.*`分别转换为相应的LLVM IR指令
  * `ExpandLargeDivRem`：**由于硬件能力限制无法支持超过目标架构可用位数长度的除法或者取余操作，故将其展开，转换成可用位数范围内的除法或者取余替代指令。当前最小支持位数是32位**
  * `CodeGenPrepare`: **主要用于配置元数据和对LLVM IR进行窥孔优化**
  * `ExceptionHandling`: **用于生成异常处理代码，根据不同的异常约定生成相应的代码。如果不需要支持异常，则此Pass不需开启**
  * `IselPrepare`: **主要是两个栈安全相关的功能实现——安全栈和栈保护，用于防止栈溢出或栈被破坏带来的安全漏洞**
* 指令选择阶段：**将LLVM IR 翻译成MIR**
* 指令选择后处理阶段：
  * `Finalize Isel`：**指令选择之后紧跟的Pass，有些目标架构自定义的伪指令会在这个阶段展开成机器指令**



**LLVM后端支持多芯片指令集导致了多后端冗余问题**——即多种指令集之间会存在相似的指令，如果每个架构都分开独立地去翻译这些指令，就会产生很多冗余的代码

**因此相关指令选择算法采取引入新的中间表示（共享框架）来进行LLVM IR到MIR的过渡**（如DAG IR 和 GMIR）



## 7.2 SelectionDAGISel 算法分析

局部指令选择算法，**以函数中的基本块为粒度，不考虑跨基本块的指令处理，只针对基本块内的LLVM IR生成最优的MIR指令**

算法实现将指令分成两类处理：

1. 以基本块为粒度，对基本块内的指令（忽略ø函数）进行指令选择
2. 针对ø函数处理基本块之间的关系，在基本块完成指令选择之后，再为基本块之间重构汇聚关系（再次添加ø函数）



1.第一类处理

**SelectionDAGISel针对基本块进行指令选择流程：**

**LLVM IR先初始化（紧跟合并优化），后进行类型合法化（紧跟合并优化）、向量合法化、类型合法化（紧跟合并优化）、操作合法化（紧跟合并优化）的合法化操作，最后进行指令选择、指令调度和MIR发射得到最终MIR**

* 其中**合并优化**基本都是一些窥孔优化：**目的是清理上一环节可能产生的冗余DAG表达，用单个节点替换同功能的多个节点组合，减轻下一个环节需要处理的节点数量**
* **类型合法化**执行了两次：**第一次是对所有的节点类型进行处理，确保处理后的数据类型都是后端架构可以支持的，然后判断基于这些数据类型的操作是否合法**；**第二次则是因为合法化处理过程中，可能会重新产生架构不支持的数据类型**，因此需要再一次处理，对新产生的数据类型清理干净

2.第二类处理

基本块之间的ø函数处理：基本块内指令处理完毕后即处理到最后一条LLVM IR即Terminator指令，**根据CFG获取后继基本块的第一条指令**。若该指令是ø函数，说明后继基本块需要重**构ø函数依赖，编译器会先记录如ø函数位置、使用变量等相关信息，在所有基本块都执行完指令选择后再重构ø函数**



引入DAG数据结构，采用SDnode节点，**抽象指令格式为一组操作码和操作数，以此屏蔽不同处理器架构和指令集之间的差异**



7.2.1 SDNode 分类

SDNode包含节点编号、操作数信息（包括操作数序列、操作数个数）、**使用者序列**、**节点对应源码在源文件中的位置**等信息，并提供获取信息的接口

SDNode输入可以是叶子节点也可以是另一个SDNode的输出
SDNode输出也称为“值”，有两种：1.标识数据流 2.标识控制流

* 标识数据流的SDNode
  * **值是数据运算操作产生的结果**，这些操作节点接受多个入参
  * 参数可以是数据流类型值，也可以是控制流类型值
* 标识控制流SDNode
  * **值用于描述节点与节点之间的关系**
  * 常见chain和glue：chain用于表示多个节点之间的顺序执行关系，glue则用于表示两个节点之间不能穿插其他的节点；其中LLVM工具输出图用红色虚线表示chain，用红色实线表示glue
  * 为什么SDNode要引入控制流关系描述？
    * 若先store写内存后load读内存，先写后读时，没有chain控制流，那么先后顺序无法确定，会引起内存读取错误；加入chain后，其作为入参也可以作为输出，即store的输出的chain用作后续load的入参
    * 对于需要进行顺序执行的操作指令同时也被称为**具有边界效应(side effect)的操作**，还有如函数调用和函数返回



### 7.2.2 LLVM IR 到 SDNode 的转换(初始化)

对单个基本块的每一条指令进行处理时，将其转换为对应的SDNode节点（LLVM IR对应一个或多个），整个基本块处理完成后即可生成对应的DAG

当所有的基本块转换完成后再处理ø函数

举例：

```c
long callee(long a, long b) {
    long c = a + b;
    return c;
}
int caller() {
    long d = 1;
    long e = 2;
    int f = callee(d, e);
    return f;
}
```

以**BPF64后端**为例，调用约定——`r1~r5`寄存器进行参数传递，`r0`寄存器存储函数返回值，且此架构中规定只有64位数据为合法数据

`clang -O0 -S -emit-llvm xx.c -o xx.ll`进行编译

```ll
define dso_local i64 @callee(i64 noundef %a, i64 noundef %b) {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %c = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %add = add nsw i64 %0, %1
  store i64 %add, ptr %c, align 8
  %2 = load i64, ptr %c, align 8
  ret i64 %2
}

declare void @llvm.dbg.declare(metadata, metadata, metadata) #1

define dso_local i32 @caller() {
entry:
  %d = alloca i64, align 8
  %e = alloca i64, align 8
  %f = alloca i32, align 4
  store i64 1, ptr %d, align 8
  store i64 2, ptr %e, align 8
  %0 = load i64, ptr %d, align 8
  %1 = load i64, ptr %e, align 8
  %call = call i64 @callee(i64 noundef %0, i64 noundef %1)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %f, align 4
  %2 = load i32, ptr %f, align 4
  ret i32 %2
}
```



下面分别介绍不同类IR到SDNode的转换

* **运算类IR——>SDNode**

  `c = a + b`对应`%add = add nsw i64 %0, %1`

  其中`nsw`是一个符号扩展标记，**表示需要进行有符号数溢出检查**

  LLVM IR指令的操作数替换为相应的SDNode 的值

  指令操作码映射为相应SDNode 的指令操作码

  `%add = add nsw i64 %0, %1`对应SDNode表达：`t13 : i64 = add nsw t11, t12`

* **类型转换类IR——>SDNode**

  LLVM IR中有显式truncate指令进行类型截断或bitcast进行位转换

  如caller函数调用callee，callee返回值类型i64，但caller用i32进行接收，此时LLVM IR会使用一个truncate指令进行返回值的截断

  `%conv = trunc i64 %call to i32`

  对应SDNode`t24 : i32= truncate t23`
  
  当需要进行扩展时，在SDNode中会增加一些类型转换节点，如`any_extend、sign_extend、zero_extend`，如本例BPF64架构仅支持64位数据类型，其中callee返回值为i64，但是f返回值为i32，存在i32到i64的隐式类型转换需求，`t28: i64 = any_extend t27`
  
* **访存类IR——>SDNode**

  以callee中第一条store指令为例

  `store i64 %a, ptr %a.addr, align 8`

  对应SDNode为`t8: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64`

  `t2`:
  
  **引入CopyFromReg，而不是直接使用物理寄存器%a**——有利于**保持**当前IR的SSA形式，**解耦**指令选择和寄存器分配阶段，**屏蔽**大部分的后端架构差异，更有利于指令选择、指令调度和寄存器分配的执行。
  
  是因为调用约定通常会要求使用物理寄存器——%a为callee函数的第一个入参，需要从物理寄存器r0中读取，此处引入t2这样的赋值指令**可将物理寄存器赋值到虚拟寄存器中**
  
  `FrameIndex<0>`:
  
  **表示栈中第0个槽位的栈变量**，即目的地址`ptr %a.addr`
  
  `undef:i64`:
  
  **描述相对目的地址的偏移量**。默认情况下store和load的最后一个输入也都是Undef，它仅仅是一个占位符
  
  **引入其主要是为了在指令选择中对store和load进行优化**：`indexed load/store 访存格式`包括一个基地址和一个偏移量。在默认情况下，load和store都不会使用最后一个字段，如果编译器发现多条指令符合该访存格式，会将这些指令转换成一条`indexed load/store`指令
  
* **函数调用相关IR——>SDNode**

  函数调用与后端架构设计密切相关，所以各个架构需要根据自身调用约定从3个方面处理相应的函数调用LLVM IR：**入参处理、函数调用、函数返回**

  **函数调用交互：**调用过程移交控制和传递参数给被调用者，被调用者返回结果和控制给调用过程

  * **callee被调用前：**

    * 准备参数给callee，将待传递参数存放在适当的寄存器或者栈单元中
    * 使用物理寄存器传参，后端调用规定可用于传参的寄存器个数，超出寄存器个数的参数会被放到栈上
  
    ```c
    %call = call i64 @callee(i64 noundef %0, i64 noundef %1)
    ```
  
    **引入CopyToReg节点来处理调用约定**，通过CopyToReg节点将两个变量的值分别赋值到物理寄存器r1和r2中，然后将r1、r2作为BPFISD::CALL(BPF架构定义的函数调用SDNode节点)的参数
  
    实际call类型还会引入伪指令节点：
  
    * **TokenFactor节点:**
      * 接收多个操作数并只产生一个操作数作为输出，其多个输入操作数关联的操作是相互独立的，即访存操作相互独立
      * TokenFactor作为call指令入参和其本身(或可以说是前置节点callseq_star)之间的节点，输出ch保证了在call指令执行前，已经全部处理完相关的参数
    * **callseq_star、callseq_end:**
      * 分别位于call指令前后，进行**动态栈分配**，**以此准确确定栈的大小和对象的位置**
    * **r2和r1之间的依赖节点(t16和t18):**
      * 使用CopyToReg节点连接load节点和对应物理寄存器
      * r1、r2之间有glue依赖，即两个CopyToReg节点用glue相连——为了保证callee执行之前，所有参数不受干扰地准备完成，再进行下一步。相应的，glue顺序没有要求，可以先r1后r2，也可以先r2后r1
  
  * **callee被调用执行：**
  
    * callee从相应寄存器或者栈单元取得参数并开始运行
  
    * 本例采用O0编译优化
  
      `clang -O0 -S -emit-llvm xx.c -o xx.ll`
  
      所有参数、局部变量都会存放在栈内存中，因此编译器会使用alloca为变量分配独立内存空间，就会有很多load/store指令进行读写（相应O2 优化则会尽量将变量存入寄存器而不是内存中，提升程序执行效率同时优化代码大小）
  
  * **callee执行结束：**
  
    * 将返回值根据调用约定放在相应的寄存器单元并移交控制权给caller
    * callee的返回指令`ret i64 %2`与call指令一样都是后端相关的
  
  * **callee被调用完成：**
  
    * caller重新获得控制权，从返回值寄存器单元中获取返回值，并继续执行
  
* **Phi指令处理**

  * 当基本块处理完毕后，发现后继基本块有ø函数，则会**创建一个虚拟寄存器**存放与之对应的**ø函数中的操作数**——**对应为该在基本块中生成CopyToReg节点，将ø函数中的操作数赋值到分配的虚拟寄存器**

  * 当所有基本块完成指令选择后，再对ø函数进行处理——LLVM IR包含**ø函数位置信息**，然后对**ø函数添加寄存器和对应作为操作数的基本块**

    * 如SDNode节点表示：`%0:gpr = PHI %2:gpr, %bb.0, %5:gpr, %bb.1`
    * %2,%5为分配的虚拟寄存器；%bb.0,%bb.1为对应基本块
  



经过以上初始化流程后，由于是为了兼容后端而设计的SDNode生成过程，导致DAG中存在大量冗余节点以及特定架构不支持的数据类型和操作类型。因此SelectionDAG初始化完成以后会先进行一次**SDNode节点合并操作**，以优化DAG图，然后会进入合法化处理阶段——**消除架构中无法处理的节点，生成可供架构进行指令选择使用的合法DAG**





### 7.2.3 SDNode 合法化

数据是操作的基础。所以**合法化过程会首先根据TD文件，对DAG中各个节点的数据类型进行校验**。如果遇到架构不支持的数据类型，需要对其进行处理，使之成为目标架构可以支持的数据类型

* **类型合法化**

  * **最小合法类型：**架构支持的多个合法类型中，**位长度最短的**；最大合法类型相反
  * **寄存器描述(在TD文件中)设计中**定义了什么数据类型是合法的
  * LLVM中存在**Legal、Promote、Expand、Soften**这4种主要的标量数据类型合法化方式。Legal即合法不需要额外处理，另外3种需要特定的处理，将不合法的数据类型转变为合法的数据类型。
    * 若以上方式都无法将非法数据类型合法化，编译器会抛出错误error而终止运行
    * 除了以上合法化方式，还有Scalarize(将数组标量化)、Split(将数组拆分)、Widen(扩展为更长的数组)等合法化方式
  * **在合法化操作之前，编译器会根据TD文件（设计者设计的寄存器描述）获得该架构支持的所有合法数据类型，并计算得到LLVM中所有数据类型对应目标架构的合法化方式**
    * 根据TD定义的寄存器类型，找到架构中支持的最大整数类型(LargestInt)，如架构仅支持32位和64位的整形寄存器，则架构支持的最大整型为64位。**所有超过最大整型的类型，都使用LargestInt为基础类型，标记为Expand，使用多个（个数满足2<sup>n</sup>）基础类型的寄存器组合来表示**
    * **所有比LargestInt最大整型小的数据类型，首先需要判断是否为后端支持的合法类型，如果不是就标记为Promote，并将该类型提升为<最近>的一个合法类型**。例如，int64为LargestInt，int32为一个合法类型，int16为非法类型，会将int16提升到int32而非int64
    * 如f128，f64，f32不合法情况下，会被转成i128，i64，i32，这种合法化方式被称为Soften
  * BPF64架构仅64位数据类型是合法的，即64位数据类型既是后端的最大整型，也是最小/最大合法类型
    * any_extend高32位是未定义的，只有低32位数据具有存在意义。Promote会把操作数类型小于目标架构的最小合法类型提升到最小合法类型(也是其最近的)。对于BPF64来说，i32需要被提升至i64，因此初始化会被引入any_extend节点，但是**Promote合法化会将any_extend节点省去，而是直接把计算的各个操作数强制转变至64位长度**，最终计算结果不需要any_extend扩展了，而是顺理成章的成为i64。即`i32 + i32 = i64 (any_extend) ——> i64 + i64 = i64`
    * 如`%add = add nsw i128 %0, %1`两个i28均超过了最大合法类型，采用Expand合法化。**将t17、t18拆分为两个内存上连续的i64类型，即原来t17、t18各自的高64位和低64位**，高低64位各自进行add操作，**最终进行进位操作**，并将低64位操作结果进位到高64位中，**最终同样取两个连续64位长度空间存放结果的高低64位**，即产生输出——t19
    * Soften合法化：`%add = fadd float %0, %1`在被初始化为SDNode时，会产生bitcast节点，将float32位输出转换成32位整型；再通过any_extend节点提升位64位整型。但由于BPF64后端并不支持f32数据类型，故而在类型合法化操作时，发现f32类型的合法化方式为Soften——**将f32类型转化为同长度i32类型，再触发Promote操作，提升至i64类型，最终获得两个i64参数，对这两个参数会再调用LLVM内嵌的浮点加法运算——_addsf3（已经在LLVM中声明，需要在架构后端进行实现）**,这样就省去了bitcast和any_extend节点

* **操作合法化**

  * 将所有的节点进行拓扑排序，从后往前逆序依次处理（即下层节点在上层节点之后，先处理上层节点）

    * **逆序遍历好处**：当下层节点发生变化的时候，上层节点可以增量式更新，避免重新计算整个DAG图的全量节点
    * 在节点合法化操作之前，**首先判断是不是有别的节点使用了当前节点，若没有则冗余**，会直接删除，不参与合法化过程

  * LLVM操作合法化主要以下几类：

    * Legal、Promote、Expand、LibCall、Custom

    * Expand尝试将操作扩展为别的操作，如果失败就会转为LibCall的方式

      * 举例：

        ```c
        #include <stdint.h>
        
        int16_t add(int16_t a, int16_t b) {
            return a + b;
        }
        ```

        其中参数和返回值类型都是i16，在初始化时会产生sign_extend_inreg节点，用于将a+b的i16结果转成i64类型(后续再复制到r0寄存器中作为返回)

        **sign_extend_inreg对应的指令操作后端并没有，故会进行Expand操作，先生成shl（左移48位）后生成sra（右移48位）的节点序列，通过将原操作扩展为位移操作来实现同样功能**

      * 举例：

        ```c
        void func()
        {
            double a = 3.14;
            double b = a / 4;
        }
        
        .ll: %div = fdiv double %0,4.000000e+00
        ```

        由于BPF64结构没有浮点除法指令，fdiv节点被替换为对LLVM内嵌函数_divf3的调用

        同时因为a的数据类型为double(f64)，不是BPF64支持的合法数据类型，所以也被转变成了合法类型i64再使用

    * Custom：**采取目标架构自定义的实现来完成该操作，这些实现可以是合法化操作的组合，也可以是设计者自己编写的代码**

      * 书中例子太抽象了不举例了，p115——开发者才会知道为什么要这么做以及怎么做，这是自定义的实现

      * 其中值得提到一点的是，当和小于其中一个入参时，进位标志设置为1

        如:

        ```
              1  (进位链)
              1010   (A=10)
            + 0111   (B=7)
            --------
            1 0001   (数学结果是17)
            ^ ^
            | |
            | +---- 4位结果 (R=1)
            +------ 进位输出 (Carry-out=1)
        ```

  * 在操作合法化过程中，会存在一些优化以及数据拆分操作，可能会产生新的节点以及未被校验是否合法的数据类型，**因此在操作合法化处理完成后，还会再进行一次数据类型合法化**，以确保DAG中节点的数据类型都是可以处理的

* 向量合法化

  * 由于一些CPU架构位了加速数据处理能力，推出了可以并行处理多个数据的指令——SIMD(单指令多数据)，即一条指令可以处理多个数据。如一条指令处理4个i64类型加法操作，操作数类型从i64变为v4i64的向量类型
  * 在编译器中增加了对向量数据类型的处理，因此不可避免地会产生后端无法支持的向量数据类型，因此也需要进行类型合法化和操作合法化。在具体情况下，可将向量转变为标量



### 7.2.4 机器指令选择

经过初始化和合法化操作后，接下来需要为这些SDNode寻找与之对应的架构指令，即“指令选择”

**SelectionDAGIsel算法会从DAG的根节点开始自底向上进行**（根节点位于DAG的出口），对每个SDNode节点进行遍历处理，为其寻找对应架构指令

LLVM会先判断被遍历节点是否被其他节点使用，**若没有则标记为冗余节点，直接跳过匹配选择，并删除该节点**



指令选择过程中，大部分SDNode节点**是依赖基于TD文件生成的匹配表MatcherTable自动完成指令选择的**。但有些特殊节点（如具有多个输出的节点）是无法通过匹配表来完成匹配的——这就需要开发者遍历这些节点，自行编写相关逻辑来完成指令的匹配



1. 匹配表介绍

   在编译构建LLVM过程中，LLVM并不是最早开始被编译的，**工程首先会构建llvm-tblgen工具，并使用该工具将TD文件解析成C/C++风格的.inc头文件**

   以BPF后端为例，**后端代码在`llvm/lib/Target/BPF`目录下的TD文件中，`llvm-tblgen`处理这些代码以后，会在构建目录`build/lib/Target/BPF`下生成相应的.inc文件**，指令选择过程中使用的inc文件名为`xxxGenDAGISel.inc`，**其中包含的静态表项MatcherTable在指令匹配选择中扮演至关重要的角色**

   

   以BPF后端生成的BPFGenDAGISel.inc文件为例，介绍匹配表MatcherTable代码片段：`p118-121`

   **匹配表中数字**——字节偏移

   **/* 0*/**——元素在数组中的索引

   **OPC_SwitchOpcode**——数组中的第一项为OPC_SwitchOpcode,表示这是一个处理SDNode的匹配表

   **/* 36 cases*/**——表示该SDNode匹配有36种情况

   **21|128,1/* 149*/**——表示当前匹配表的大小。由变长的编码存储数据的方式知，用最高位来表示下一个数据是否属于当前的数据一部分，如`21｜128`最高位为1，表示后面的数据1也是属于当前的数据一部分。最终得到`( 1 << 7 ) + 21 = 149 `刚好是注释里的内容。

   **// —>154**——LLVM会记录每个SDNode对应匹配片段在整张匹配表中的起始位置，如匹配表第一行尾部的`// —>154`，表示从154字节处开始定义一个新的匹配节点，即`ISD::STORE`。通**过OPC_Scope记录的节点可以实现接下来不匹配的直接跳转，因为匹配表非常庞大，这样可以加速指令匹配过程**

   **OPC_xxx**——对应匹配流程的行为

   

2. 匹配演示过程 p122-123

   这个debug模式的编译器处理日志非常清晰



指令选择结束后，只有伪指令节点没有匹配为真实后端指令，如`EntryToken、CopyToReg、CopyFromReg`。**这样保留部分伪指令有利于后续寄存器分配、编译优化的工作，另一方面当前阶段编译器确实无法得知这些伪节点如何被硬件执行**。这些节点一般被保留在MIR中，在后续工作中进行处理



### 7.2.5 从DAG到MIR

代码表达经过机器匹配后仍然是DAG的形式（机器DAG，边用于存储依赖关系，不变，而节点均被机器指令匹配了），之后编译器需要遍历每个SDNode节点，生成与之对应的MIR。在进行生成MIR之前，编译器会先对DAG的节点进行优化，chain和glue等会在调度过程中被使用并最终消除，最终产生的MIR中将不携带这些信息。



**DAG的SDNode节点发射生成MIR两种情况：**

* SDNode在指令选择阶段已经匹配到了机器指令，直接生成相应的MIR，并放入与MIR对应的MBB（机器基本块）中，生成MIR过程如下：
  * 根据指令选择结果**新建相应的MIR**
  * 将原SDNode节点相关的**操作数、数据结构**中的节点属性等信息，相应地复制到MIR节点和数据结构中
  * 将MIR**插入**到MBB中的相应位置
* 一些特殊节点是**架构无关的且一般会存在控制流依赖**，后端架构中并不能通过指令选择找到与这些节点对应的汇编指令，如之前提到的伪指令节点。其会被转为相关伪指令放入到MBB中，如`CopyToReg、CopyFromReg伪指令节点——>COPY伪指令`，在后续优化会被消除或转换为真实机器指令



举例：

指令选择后callee DAG表达

```
Selected Selection DAG: %bb.0 'func:entry'
SelectionDAG has 20 nodes:
	t0: ch = EntryToken
		t4: i64, ch = CopyFromReg t0, Register:i64 %1
			t2: i64, ch = CopyFromReg t0, Register:i64 %0
		t8: ch = STRICT_STK_MEM:i64:store t0, TargetConstant:i64<0>, t2
	t10: ch = STRICT_STK_MEM:i64:store (s64) into %ir.a.addr> t4, TargetFrameIndex:i64<1>, 	TargetConstant:i64<0>, t8
	t12: i64, ch = LDDKMem:i64:dereferenceable load (s64) from %ir.b.addr> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t10
	t11: i64, ch = LDDKMem:i64:dereferenceable load (s64) from %ir.a.addr> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t10
		t13: i64 = ADD_rr nsw t11, t12
		t15: ch = TokenFactor t11:1, t12:1
	t16: ch = STRICT_MEM:i64:store (s64) into %ir.c> t13, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t15
		t17: i64, ch = LDDKMem:i64:dereferenceable load (s64) from %ir.c> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t16
	t19: ch,glue = CopyToReg t16, Register:i64 $t0, t17
	t20: ch = RET Register:i64 $t0, t19, t19:1
```

在经过MIR生成处理后：

```ll
Function Live Ins: $r1 in %0, $r2 in %1

bb.0.entry:
  liveins: $r1, $r2

  %0:gpr = COPY $r1
  %1:gpr = COPY $r2
  STD %1:gpr, %stack.0.a.addr, 0 :: (store (s64) into %ir.a.addr)
  STD %0:gpr, %stack.1.b.addr, 0 :: (store (s64) into %ir.b.addr)
  %2:gpr = LDD %stack.0.a.addr, 0 :: (dereferenceable load (s64) from %ir.a.addr)
  %3:gpr = LDD %stack.1.b.addr, 0 :: (dereferenceable load (s64) from %ir.b.addr)
  %4:gpr = nsw ADD_rr %2:gpr(tied-def 0), killed %3:gpr
  STD killed %4:gpr, %stack.2.c, 0 :: (store (s64) into %ir.c)
  %5:gpr = LDD %stack.2.c, 0 :: (dereferenceable load (s64) from %ir.c)
  $r0 = COPY %5:gpr
  RET implicit $r0

# End machine code for function func.
```



SDNode——MIR后，控制流依赖的chain和glue会被完全消除，所有指令都变成了线性的机器指令。

由于还没有确定用哪些寄存器来存储值，即还依赖“寄存器分配”；并且这一阶段指令并不是最高效的，还需经过后端优化。因此不能直接映射成机器汇编运行
