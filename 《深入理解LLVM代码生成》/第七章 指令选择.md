# 第七章 指令选择

**将高级语言映射成目标架构指令**的过程称为指令选择

映射可能一对一，也可能多对一



指令选择需要解决模式匹配和模式选择两个子问题

**模式匹配：**单指令匹配、树匹配、DAG匹配和图匹配

**模式选择：**以最短运行时间和最小内存开销为目标

处理方式：

1. **分开处理：**先匹配后选择，**可以取到最优**

2. **两阶段合并处理：(启发式算法) **一边匹配一边判断是否为当前最优，最终可以得到**一个相对好的匹配结果，处理时间较前一种更短**



## 7.1 指令选择的处理流程

1. 指令选择模块在后端实现，但它并不是后端第一个Pass，而在其之前还会进行LLVM IR的相关工作：
   1. **进一步降低LLVM IR 和后端IR的语义差异**，方便后续进行后端IR的变换
   2. **进行一些功能的处理**，如异常处理和`inrinsic`处理
2. 指令选择执行完成之后，**还会有`Finalize Isel`的过程来完成指令选择相关的一些事情**

综上所述，将指令选择分为3个阶段：**指令选择预处理阶段、指令选择阶段、指令选择后处理阶段**



* 指令选择预处理阶段相关Pass：
  * `PreISelIntrinsicLowering`：**对LLVM内置函数进行降级——即将一个高级、抽象的内置函数，转换为一个由更简单、更基础的IR指令组成的等价实现，或者直接转换成一个对标准库函数的调用**
    * 将两类`inrinsic`指令（LLVM内部定义的特殊指令），以及`llvm.load.relative` 和 `llvm.objc.*`分别转换为相应的LLVM IR指令
  * `ExpandLargeDivRem`：**由于硬件能力限制无法支持超过目标架构可用位数长度的除法或者取余操作，故将其展开，转换成可用位数范围内的除法或者取余替代指令。当前最小支持位数是32位**
  * `CodeGenPrepare`: **主要用于配置元数据和对LLVM IR进行窥孔优化**
  * `ExceptionHandling`: **用于生成异常处理代码，根据不同的异常约定生成相应的代码。如果不需要支持异常，则此Pass不需开启**
  * `IselPrepare`: **主要是两个栈安全相关的功能实现——安全栈和栈保护，用于防止栈溢出或栈被破坏带来的安全漏洞**
* 指令选择阶段：**将LLVM IR 翻译成MIR**
* 指令选择后处理阶段：
  * `Finalize Isel`：**指令选择之后紧跟的Pass，有些目标架构自定义的伪指令会在这个阶段展开成机器指令**



**LLVM后端支持多芯片指令集导致了多后端冗余问题**——即多种指令集之间会存在相似的指令，如果每个架构都分开独立地去翻译这些指令，就会产生很多冗余的代码

**因此相关指令选择算法采取引入新的中间表示（共享框架）来进行LLVM IR到MIR的过渡**（如DAG IR 和 GMIR）



## 7.2 SelectionDAGISel 算法分析

局部指令选择算法，**以函数中的基本块为粒度，不考虑跨基本块的指令处理，只针对基本块内的LLVM IR生成最优的MIR指令**

算法实现将指令分成两类处理：

1. 以基本块为粒度，对基本块内的指令（忽略ø函数）进行指令选择
2. 针对ø函数处理基本块之间的关系，在基本块完成指令选择之后，再为基本块之间重构汇聚关系（再次添加ø函数）



1.第一类处理

**SelectionDAGISel针对基本块进行指令选择流程：**

**LLVM IR先初始化（紧跟合并优化），后进行类型合法化（紧跟合并优化）、向量合法化、类型合法化（紧跟合并优化）、操作合法化（紧跟合并优化）的合法化操作，最后进行指令选择、指令调度和MIR发射得到最终MIR**

* 其中**合并优化**基本都是一些窥孔优化：**目的是清理上一环节可能产生的冗余DAG表达，用单个节点替换同功能的多个节点组合，减轻下一个环节需要处理的节点数量**
* **类型合法化**执行了两次：**第一次是对所有的节点类型进行处理，确保处理后的数据类型都是后端架构可以支持的，然后判断基于这些数据类型的操作是否合法**；**第二次则是因为合法化处理过程中，可能会重新产生架构不支持的数据类型**，因此需要再一次处理，对新产生的数据类型清理干净

2.第二类处理

基本块之间的ø函数处理：基本块内指令处理完毕后即处理到最后一条LLVM IR即Terminator指令，**根据CFG获取后继基本块的第一条指令**。若该指令是ø函数，说明后继基本块需要重**构ø函数依赖，编译器会先记录如ø函数位置、使用变量等相关信息，在所有基本块都执行完指令选择后再重构ø函数**



引入DAG数据结构，采用SDnode节点，**抽象指令格式为一组操作码和操作数，以此屏蔽不同处理器架构和指令集之间的差异**



7.2.1 SDNode 分类

SDNode包含节点编号、操作数信息（包括操作数序列、操作数个数）、**使用者序列**、**节点对应源码在源文件中的位置**等信息，并提供获取信息的接口

SDNode输入可以是叶子节点也可以是另一个SDNode的输出
SDNode输出也称为“值”，有两种：1.标识数据流 2.标识控制流

* 标识数据流的SDNode
  * **值是数据运算操作产生的结果**，这些操作节点接受多个入参
  * 参数可以是数据流类型值，也可以是控制流类型值
* 标识控制流SDNode
  * **值用于描述节点与节点之间的关系**
  * 常见chain和glue：chain用于表示多个节点之间的顺序执行关系，glue则用于表示两个节点之间不能穿插其他的节点；其中LLVM工具输出图用红色虚线表示chain，用红色实线表示glue
  * 为什么SDNode要引入控制流关系描述？
    * 若先store写内存后load读内存，先写后读时，没有chain控制流，那么先后顺序无法确定，会引起内存读取错误；加入chain后，其作为入参也可以作为输出，即store的输出的chain用作后续load的入参
    * 对于需要进行顺序执行的操作指令同时也被称为**具有边界效应(side effect)的操作**，还有如函数调用和函数返回



7.2.2 LLVM IR 到 SDNode 的转换

对单个基本块的每一条指令进行处理时，将其转换为对应的SDNode节点（LLVM IR对应一个或多个），整个基本块处理完成后即可生成对应的DAG

当所有的基本块转换完成后再处理ø函数

举例：

```c
long callee(long a, long b) {
    long c = a + b;
    return c;
}
int caller() {
    long d = 1;
    long e = 2;
    int f = callee(d, e);
    return f;
}
```

以**BPF64后端**为例，调用约定——`r1~r5`寄存器进行参数传递，`r0`寄存器存储函数返回值，且此架构中规定只有64位数据为合法数据

`clang -O0 -S -emit-llvm xx.c -o xx.ll`进行编译

```ll
define dso_local i64 @callee(i64 noundef %a, i64 noundef %b) {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %c = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %add = add nsw i64 %0, %1
  store i64 %add, ptr %c, align 8
  %2 = load i64, ptr %c, align 8
  ret i64 %2
}

declare void @llvm.dbg.declare(metadata, metadata, metadata) #1

define dso_local i32 @caller() {
entry:
  %d = alloca i64, align 8
  %e = alloca i64, align 8
  %f = alloca i32, align 4
  store i64 1, ptr %d, align 8
  store i64 2, ptr %e, align 8
  %0 = load i64, ptr %d, align 8
  %1 = load i64, ptr %e, align 8
  %call = call i64 @callee(i64 noundef %0, i64 noundef %1)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %f, align 4
  %2 = load i32, ptr %f, align 4
  ret i32 %2
}
```



下面分别介绍不同类IR到SDNode的转换

* **运算类IR——>SDNode**

  `c = a + b`对应`%add = add nsw i64 %0, %1`

  其中`nsw`是一个符号扩展标记，**表示需要进行有符号数溢出检查**

  LLVM IR指令的操作数替换为相应的SDNode 的值

  指令操作码映射为相应SDNode 的指令操作码

  `%add = add nsw i64 %0, %1`对应SDNode表达：`t13 : i64 = add nsw t11, t12`

* **类型转换类IR——>SDNode**

  LLVM IR中有显式truncate指令进行类型截断或bitcast进行位转换

  如caller函数调用callee，callee返回值类型i64，但caller用i32进行接收，此时LLVM IR会使用一个truncate指令进行返回值的截断

  `%conv = trunc i64 %call to i32`

  对应SDNode`t24 : i32= truncate t23`
